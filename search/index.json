[{"content":"斜体和粗体 代码 1 2 3 4  1.*斜体*或_斜体_ 2.**粗体** 3.***加粗斜体*** 4.~~删除线~~   样式： 斜体\n粗体\n加粗粗体\n删除线\n分级标题 代码 第一种写法 1 2 3 4  这是一个一级标题 ============================ 这是一个二级标题 --------------------------------------------------   第二种写法 1 2 3 4 5 6  # 一级标题 ## 二级标题 ### 三级标题 #### 四级标题 ##### 五级标题 ###### 六级标题   超链接 行内式 语法说明： [ ]里写链接文字，( )里写链接地址, ( )中的”“中可以为链接指定 title 属性，title 属性可加可不加。title 属性的效果是鼠标悬停在链接上会出现指定的 title 文字。[链接文字](链接地址 “链接标题”)’这样的形式。链接地址与链接标题前有一个空格\n代码 1 2  欢迎来到[梵居闹市](http://blog.leanote.com/freewalk) 欢迎来到[梵居闹市](http://blog.leanote.com/freewalk \u0026#34;梵居闹市\u0026#34;)   样式 梵居闹市\n参考式 参考式超链接一般用在学术论文上面，或者另一种情况，如果某一个链接在文章中多处使用，那么使用引用 的方式创建链接将非常好，它可以让你对链接进行统一的管理\n语法说明： 参考式链接分为两部分，文中的写法 [链接文字][链接标记]，在文本的任意位置添加[链接标记]:链接地址 “链接标题”，链接地址与链接标题前有一个空格。\n如果链接文字本身可以做为链接标记，你也可以写成[链接文字][] [链接文字]：链接地址的形式，见代码的最后一行。\n代码 1 2 3 4 5 6  我经常去的几个网站[Google][1]、[Leanote][2]以及[自己的博客][3] [Leanote 笔记][2]是一个不错的[网站][]。 [1]:http://www.google.com \u0026#34;Google\u0026#34; [2]:http://www.leanote.com \u0026#34;Leanote\u0026#34; [3]:http://http://blog.leanote.com/freewalk \u0026#34;梵居闹市\u0026#34; [网站]:http://http://blog.leanote.com/freewalk   样式 我经常去的几个网站[Google][1]、[Leanote][2]以及[自己的博客][3] [Leanote 笔记][2]是一个不错的[网站][]。 [1]:http://www.google.com \u0026ldquo;Google\u0026rdquo; [2]:http://www.leanote.com \u0026ldquo;Leanote\u0026rdquo; [3]:http://http://blog.leanote.com/freewalk \u0026ldquo;梵居闹市\u0026rdquo; [网站]:http://http://blog.leanote.com/freewalk\n自动链接 语法说明： Markdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用\u0026lt;\u0026gt;包起来， Markdown 就会自动把它转成链接。一般网址的链接文字就和链接地址一样，例如：\n1 2  \u0026lt;http://example.com/\u0026gt; \u0026lt;address@example.com\u0026gt;   样式 http://example.com/ address@example.com\n锚点 网页中，锚点其实就是页内超链接，也就是链接本文档内部的某些元素，实现当前页面中的跳转。比如我这里写下一个锚点，点击回到目录，就能跳转到目录。 在目录中点击这一节，就能跳过来。还有下一节的注脚。这些根本上都是用锚点来实现的。\n语法描述 在你准备跳转到的指定标题后插入锚点{#标记}，然后在文档的其它地方写上连接到锚点的链接。\n代码 1 2 3  ## 0. 目录{#index} 跳转到[目录](#index){#index}   跳转到自动链接\n列表 无序列表 语法描述 使用 *，+，- 表示无序列表。\n代码 1 2 3  - 无序列表项 一 - 无序列表项 二 - 无序列表项 三   样式  - 无序列表项 一 - 无序列表项 二 - 无序列表项 三  有序列表 语法描述 有序列表则使用数字接着一个英文句点。\n代码 1 2 3  1. 有序列表项 一 2. 有序列表项 二 3. 有序列表项 三   样式  1. 有序列表项 一 2. 有序列表项 二 3. 有序列表项 三  定义型列表？ 语法说明： 定义型列表由名词和解释组成。一行写上定义，紧跟一行写上解释。解释的写法:紧跟一个缩进(Tab)\n代码： 1 2 3 4 5 6 7 8  Markdown : 轻量级文本标记语言，可以转换成html，pdf等格式（左侧有一个可见的冒号和四个不可见的空格） 代码块 2 : 这是代码块的定义（左侧有一个可见的冒号和四个不可见的空格） 代码块（左侧有八个不可见的空格）   列表缩进 语法说明： 列表项目标记通常是放在最左边，但是其实也可以缩进，最多 3 个空格，项目标记后面则一定要接着至少一个空格或制表符。*+tab\n要让列表看起来更漂亮，你可以把内容用固定的缩进整理好（显示效果与代码一致）：\n  轻轻的我走了， 正如我轻轻的来； 我轻轻的招手， 作别西天的云彩。 那河畔的金柳， 是夕阳中的新娘； 波光里的艳影， 在我的心头荡漾。 软泥上的青荇， 油油的在水底招摇； 在康河的柔波里， 我甘心做一条水草！\n  那榆荫下的一潭， 不是清泉， 是天上虹； 揉碎在浮藻间， 沉淀着彩虹似的梦。 寻梦？撑一支长篙， 向青草更青处漫溯； 满载一船星辉， 在星辉斑斓里放歌。 但我不能放歌， 悄悄是别离的笙箫； 夏虫也为我沉默， 沉默是今晚的康桥！ 悄悄的我走了， 正如我悄悄的来； 我挥一挥衣袖， 不带走一片云彩。\n  包含引用的列表 语法说明： 如果要在列表项目内放进引用，那 \u0026gt; 就需要缩进：\n代码 1 2 3  * 阅读的方法: \u0026gt; 打开书本。 \u0026gt; 打开电灯。   样式   阅读的方法\n 打开书本\n打开电灯\n   包含代码区块的引用？ 语法说明 如果要放代码区块的话，该区块就需要缩进两次，也就是 8 个空格或是 2 个制表符：\n特殊情况 在特殊情况下，项目列表很可能会不小心产生，像是下面这样的写法：\n1 2  1986. What a great season. 显示What a great season.   换句话说，也就是在行首出现数字-句点-空白，要避免这样的状况，你可以在句点前面加上反斜杠：\n1  1986\\. What a great season.   引用 语法说明： 引用需要在被引用的文本前加上\u0026gt;符号。\n代码： 1 2 3 4 5 6  \u0026gt; 这是一个有两段文字的引用, \u0026gt; 无意义的占行文字1. \u0026gt; 无意义的占行文字2. \u0026gt; \u0026gt; 无意义的占行文字3. \u0026gt; 无意义的占行文字4.   样式  这是一个有两段文字的引用, 无意义的占行文字 1. 无意义的占行文字 2.\n无意义的占行文字 3. 无意义的占行文字 4.\n Markdown 也允许你偷懒只在整个段落的第一行最前面加上 \u0026gt; ：\n引用的多层嵌套 区块引用可以嵌套（例如：引用内的引用），只要根据层次加上不同数量的 \u0026gt; ：\n代码 1 2 3  \u0026gt;\u0026gt;\u0026gt; 请问 Markdwon 怎么用？ - 小白 \u0026gt;\u0026gt; 自己看教程！ - 愤青 \u0026gt; 教程在哪？ - 小白      请问 Markdwon 怎么用？ - 小白\n  自己看教程！ - 愤青\n 教程在哪？ - 小白\n      引用其它要素 引用的区块内也可以使用其他的 Markdown 语法，包括标题、列表、代码区块等：\n代码 1 2 3 4 5 6 7  \u0026gt; 1. 这是第一行列表项。 \u0026gt; 2. 这是第二行列表项。 \u0026gt; \u0026gt; 给出一些例子代码： \u0026gt; \u0026gt; return shell_exec(\u0026#34;echo $input | $markdown_script\u0026#34;);     这是第一行列表项。 这是第二行列表项。  给出一些例子代码：\nreturn shell_exec(\u0026quot;echo $input | $markdown_script\u0026quot;);   插入图像 图片的创建方式与超链接相似，而且和超链接一样也有两种写法，行内式和参考式写法。\n语法中图片 Alt 的意思是如果图片因为某些原因不能显示，就用定义的图片 Alt 文字来代替图片。 图片 Title 则和链接中的 Title 一样，表示鼠标悬停与图片上时出现的文字。 Alt 和 Title 都不是必须的，可以省略，但建议写上。\n行内式 语法说明 1  ![图片Alt](图片地址 “图片Title”)   样式 ![图片Alt](图片地址 “图片 Title”)\n参考式 语法说明 1 2 3  在文档要插入图片的地方写![图片Alt][标记] 在文档的最后写上[标记]:图片地址 “Title”   代码 1 2 3 4  美丽花儿： ![美丽花儿][flower] [flower]:http://ww2.sinaimg.cn/large/56d258bdjw1eugeubg8ujj21kw16odn6.jpg \u0026#34;美丽花儿\u0026#34;   美丽花儿： 目录 在段落中填写 [TOC] 以显示全文内容的目录结构。\n注脚 语法说明： 1 2 3 4 5  语法说明： 在需要添加注脚的文字后加上脚注名字[^注脚名字],称为加注。 然后在文本的任意位置(一般在最后)添加脚注，脚注前必须有对应的脚注名字。 注意：经测试注脚与注脚之间必须空一行，不然会失效。成功后会发现，即使你没有把注脚写在文末，经Markdown转换后，也会自动归类到文章的最后。   代码 1 2 3 4  使用 Markdown[^1]可以效率的书写文档, 直接转换成 HTML[^2], 你可以使用 Leanote[^Le] 编辑器进行书写。 [^1]:Markdown是一种纯文本标记语言 [^2]:HyperText Markup Language 超文本标记语言 [^Le]:开源笔记平台，支持Markdown和笔记直接发为博文   样式 使用 Markdown1可以效率的书写文档, 直接转换成 HTML2, 你可以使用 Leanote3 编辑器进行书写。\nLaTeX 公式? $表示行内公式 代码 1  质能守恒方程可以用一个很简洁的方程式 $E=mc^2$ 来表达。   样式 质能守恒方程可以用一个很简洁的方程式 $E=mc^2$ 来表达。\n$$ 表示整行公式 代码 1 2 3 4  $$\\sum_{i=1}^n a_i=0$$ $$f(x_1,x_x,\\ldots,x_n) = x_1^2 + x_2^2 + \\cdots + x_n^2 $$ $$\\sum^{j-1}_{k=0}{\\widehat{\\gamma}_{kj} z_k}$$   样式 $$\\sum_{i=1}^n a_i=0$$ $$f(x_1,x_x,\\ldots,x_n) = x_1^2 + x_2^2 + \\cdots + x_n^2 $$ $$\\sum^{j-1}{k=0}{\\widehat{\\gamma}{kj} z_k}$$\n详情\n流程图 代码 1 2 3 4 5 6 7 8 9 10  flow st=\u0026gt;start: Start:\u0026gt;https://www.zybuluo.com io=\u0026gt;inputoutput: verification op=\u0026gt;operation: Your Operation cond=\u0026gt;condition: Yes or No? sub=\u0026gt;subroutine: Your Subroutine e=\u0026gt;end st-\u0026gt;io-\u0026gt;op-\u0026gt;cond cond(yes)-\u0026gt;e cond(no)-\u0026gt;sub-\u0026gt;io   详情\n表格 语法说明：  不管是哪种方式，第一行为表头，第二行分隔表头和主体部分，第三行开始每一行为一个表格行。 列于列之间用管道符|隔开。原生方式的表格每一行的两边也要有管道符。 第二行还可以为不同的列指定对齐方向。默认为左对齐，在-右边加上:就右对齐。  代码： 简单方式写表格：\n1 2 3 4 5  学号|姓名|分数 -|-|- 小明|男|75 小红|女|79 小陆|男|92   原生方式写表格：\n1 2 3 4 5  |学号|姓名|分数| |-|-|-| |小明|男|75| |小红|女|79| |小陆|男|92|   为表格第二列指定方向：\n1 2 3 4  产品|价格 -|-: Leanote 高级账号|60元/年 Leanote 超级账号|120元/年      学号 姓名 分数     小明 男 75   小红 女 79   小陆 男 92       学号 姓名 分数     小明 男 75   小红 女 79   小陆 男 92       产品 价格     Leanote 高级账号 60 元/年   Leanote 超级账号 120 元/年    分割线 你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线\n代码： 1 2 3 4 5  * * * *** ***** - - - ---------------------------------------   样式      代码 对于程序员来说这个功能是必不可少的，插入程序代码的方式有两种，一种是利用缩进(Tab), 另一种是利用”`”符号（一般在 ESC 键下方）包裹代码。\n语法说明：\n插入行内代码，即插入一个单词或者一句代码的情况，使用code这样的形式插入。 插入多行代码，可以使用缩进或者“ code “,具体看示例。 注意： 缩进式插入前方必须有空行\n行内式 代码 1  C语言里的函数 `scanf()` 怎么使用？   C 语言里的函数 scanf() 怎么使用？\n缩进式多行代码 缩进 4 个空格或是 1 个制表符\n一个代码区块会一直持续到没有缩进的那一行（或是文件结尾）。\n代码： 1 2 3 4 5  #include \u0026lt;stdio.h\u0026gt; int main(void) { printf(\u0026#34;Hello world\\n\u0026#34;); }   用六个`包裹多行代码 代码： 1 2 3 4 5 6 7  ``` #include \u0026lt;stdio.h\u0026gt; int main(void) { printf(\u0026#34;Hello world\\n\u0026#34;); } 、、、   HTML 原始码 在代码区块里面， \u0026amp; 、 \u0026lt; 和 \u0026gt; 会自动转成 HTML 实体，这样的方式让你非常容易使用 Markdown 插入范例用的 HTML 原始码，只需要复制贴上，剩下的 Markdown 都会帮你处理，例如：\n代码： 第一个例子：\n1 2 3  \u0026lt;div class=\u0026#34;footer\u0026#34;\u0026gt; © 2004 Foo Corporation \u0026lt;/div\u0026gt;   第二个例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13  \u0026lt;table\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th rowspan=\u0026#34;2\u0026#34;\u0026gt;值班人员\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;星期一\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;星期二\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;星期三\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;李强\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;张明\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;王平\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt;     Markdown 是一种纯文本标记语言\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n HyperText Markup Language 超文本标记语言\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n 开源笔记平台，支持 Markdown 和笔记直接发为博文\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   ","date":"2022-05-14T00:00:00Z","permalink":"https://example.com/2022/markdown/","title":"Markdown"},{"content":"Vue3 快速上手 1.Vue3 简介  2020 年 9 月 18 日，Vue.js 发布 3.0 版本，代号：One Piece（海贼王） 耗时 2 年多、2600+次提交、30+个 RFC、600+次 PR、99 位贡献者 github 上的 tags 地址：https://github.com/vuejs/vue-next/releases/tag/v3.0.0  2.Vue3 带来了什么 1.性能的提升   打包大小减少 41%\n  初次渲染快 55%, 更新渲染快 133%\n  内存减少 54%\n\u0026hellip;\u0026hellip;\n  2.源码的升级   使用 Proxy 代替 defineProperty 实现响应式\n  重写虚拟 DOM 的实现和 Tree-Shaking\n\u0026hellip;\u0026hellip;\n  3.拥抱 TypeScript  Vue3 可以更好的支持 TypeScript  4.新的特性   Composition API（组合 API）\n setup 配置 ref 与 reactive watch 与 watchEffect provide 与 inject \u0026hellip;\u0026hellip;    新的内置组件\n Fragment Teleport Suspense    其他改变\n 新的生命周期钩子 data 选项应始终被声明为一个函数 移除 keyCode 支持作为 v-on 的修饰符 \u0026hellip;\u0026hellip;    一、创建 Vue3.0 工程 1.使用 vue-cli 创建 官方文档：https://cli.vuejs.org/zh/guide/creating-a-project.html#vue-create\n1 2 3 4 5 6 7 8 9  ## 查看@vue/cli版本，确保@vue/cli版本在4.5.0以上 vue --version ## 安装或者升级你的@vue/cli npm install -g @vue/cli ## 创建 vue create vue_test ## 启动 cd vue_test npm run serve   2.使用 vite 创建 官方文档：https://v3.cn.vuejs.org/guide/installation.html#vite\nvite 官网：https://vitejs.cn\n 什么是 vite？—— 新一代前端构建工具。 优势如下：  开发环境中，无需打包操作，可快速的冷启动。 轻量快速的热重载（HMR）。 真正的按需编译，不再等待整个应用编译完成。   传统构建 与 vite 构建对比图  1 2 3 4 5 6 7 8  ## 创建工程 npm init vite-app \u0026lt;project-name\u0026gt; ## 进入工程目录 cd \u0026lt;project-name\u0026gt; ## 安装依赖 npm install ## 运行 npm run dev   二、常用 Composition API 官方文档: https://v3.cn.vuejs.org/guide/composition-api-introduction.html\n1.拉开序幕的 setup  理解：Vue3.0 中一个新的配置项，值为一个函数。 setup 是所有Composition API（组合 API）“ 表演的舞台 ”。 组件中所用到的：数据、方法等等，均要配置在 setup 中。 setup 函数的两种返回值：  若返回一个对象，则对象中的属性、方法, 在模板中均可以直接使用。（重点关注！） 若返回一个渲染函数：则可以自定义渲染内容。（了解）   注意点：  尽量不要与 Vue2.x 配置混用  Vue2.x 配置（data、methos、computed\u0026hellip;）中可以访问到setup 中的属性、方法。 但在 setup 中不能访问到Vue2.x 配置（data、methos、computed\u0026hellip;）。 如果有重名, setup 优先。   setup 不能是一个 async 函数，因为返回值不再是 return 的对象, 而是 promise, 模板看不到 return 对象中的属性。（后期也可以返回一个 Promise 实例，但需要 Suspense 和异步组件的配合）    2.ref 函数  作用: 定义一个响应式的数据 语法: const xxx = ref(initValue)  创建一个包含响应式数据的引用对象（reference 对象，简称 ref 对象）。 JS 中操作数据： xxx.value 模板中读取数据: 不需要.value，直接：\u0026lt;div\u0026gt;{{xxx}}\u0026lt;/div\u0026gt;   备注：  接收的数据可以是：基本类型、也可以是对象类型。 基本类型的数据：响应式依然是靠Object.defineProperty()的get与set完成的。 对象类型的数据：内部 “ 求助 ”了 Vue3.0 中的一个新函数—— reactive函数。    3.reactive 函数  作用: 定义一个对象类型的响应式数据（基本类型不要用它，要用ref函数） 语法：const 代理对象= reactive(源对象)接收一个对象（或数组），返回一个代理对象（Proxy 的实例对象，简称 proxy 对象） reactive 定义的响应式数据是“深层次的”。 内部基于 ES6 的 Proxy 实现，通过代理对象操作源对象内部数据进行操作。  4.Vue3.0 中的响应式原理 vue2.x 的响应式   实现原理：\n  对象类型：通过Object.defineProperty()对属性的读取、修改进行拦截（数据劫持）。\n  数组类型：通过重写更新数组的一系列方法来实现拦截。（对数组的变更方法进行了包裹）。\n1 2 3 4  Object.defineProperty(data, \u0026#39;count\u0026#39;, { get() {}, set() {} });       存在问题：\n 新增属性、删除属性, 界面不会更新。 直接通过下标修改数组, 界面不会自动更新。    Vue3.0 的响应式  实现原理:   通过 Proxy（代理）: 拦截对象中任意属性的变化, 包括：属性值的读写、属性的添加、属性的删除等。\n  通过 Reflect（反射）: 对源对象的属性进行操作。\n  MDN 文档中描述的 Proxy 与 Reflect：\n  Proxy：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy\n  Reflect：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  new Proxy(data, { // 拦截读取属性值  get(target, prop) { return Reflect.get(target, prop); }, // 拦截设置属性值或添加新属性  set(target, prop, value) { return Reflect.set(target, prop, value); }, // 拦截删除属性  deleteProperty(target, prop) { return Reflect.deleteProperty(target, prop); } }); proxy.name = \u0026#39;tom\u0026#39;;         5.reactive 对比 ref  从定义数据角度对比：  ref 用来定义：基本类型数据。 reactive 用来定义：对象（或数组）类型数据。 备注：ref 也可以用来定义对象（或数组）类型数据, 它内部会自动通过reactive转为代理对象。   从原理角度对比：  ref 通过Object.defineProperty()的get与set来实现响应式（数据劫持）。 reactive 通过使用Proxy来实现响应式（数据劫持）, 并通过Reflect操作源对象内部的数据。   从使用角度对比：  ref 定义的数据：操作数据需要.value，读取数据时模板中直接读取不需要.value。 reactive 定义的数据：操作数据与读取数据：均不需要.value。    6.setup 的两个注意点  setup 执行的时机  在 beforeCreate 之前执行一次，this 是 undefined。   setup 的参数  props：值为对象，包含：组件外部传递过来，且组件内部声明接收了的属性。 context：上下文对象  attrs: 值为对象，包含：组件外部传递过来，但没有在 props 配置中声明的属性, 相当于 this.$attrs。 slots: 收到的插槽内容, 相当于 this.$slots。 emit: 分发自定义事件的函数, 相当于 this.$emit。      7.计算属性与监视 1.computed 函数   与 Vue2.x 中 computed 配置功能一致\n  写法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  import {computed} from \u0026#39;vue\u0026#39; setup(){ ... //计算属性——简写  let fullName = computed(()=\u0026gt;{ return person.firstName + \u0026#39;-\u0026#39; + person.lastName }) //计算属性——完整  let fullName = computed({ get(){ return person.firstName + \u0026#39;-\u0026#39; + person.lastName }, set(value){ const nameArr = value.split(\u0026#39;-\u0026#39;) person.firstName = nameArr[0] person.lastName = nameArr[1] } }) }     2.watch 函数   与 Vue2.x 中 watch 配置功能一致\n  两个小“坑”：\n 监视 reactive 定义的响应式数据时：oldValue 无法正确获取、强制开启了深度监视（deep 配置失效）。 监视 reactive 定义的响应式数据中某个属性时：deep 配置有效。  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52  //情况一：监视ref定义的响应式数据 watch( sum, (newValue, oldValue) =\u0026gt; { console.log(\u0026#39;sum变化了\u0026#39;, newValue, oldValue); }, { immediate: true } ); //情况二：监视多个ref定义的响应式数据 watch([sum, msg], (newValue, oldValue) =\u0026gt; { console.log(\u0026#39;sum或msg变化了\u0026#39;, newValue, oldValue); }); /* 情况三：监视reactive定义的响应式数据 若watch监视的是reactive定义的响应式数据，则无法正确获得oldValue！！ 若watch监视的是reactive定义的响应式数据，则强制开启了深度监视 */ watch( person, (newValue, oldValue) =\u0026gt; { console.log(\u0026#39;person变化了\u0026#39;, newValue, oldValue); }, { immediate: true, deep: false } ); //此处的deep配置不再奏效  //情况四：监视reactive定义的响应式数据中的某个属性 watch( () =\u0026gt; person.job, (newValue, oldValue) =\u0026gt; { console.log(\u0026#39;person的job变化了\u0026#39;, newValue, oldValue); }, { immediate: true, deep: true } ); //情况五：监视reactive定义的响应式数据中的某些属性 watch( [() =\u0026gt; person.job, () =\u0026gt; person.name], (newValue, oldValue) =\u0026gt; { console.log(\u0026#39;person的job变化了\u0026#39;, newValue, oldValue); }, { immediate: true, deep: true } ); //特殊情况 watch( () =\u0026gt; person.job, (newValue, oldValue) =\u0026gt; { console.log(\u0026#39;person的job变化了\u0026#39;, newValue, oldValue); }, { deep: true } ); //此处由于监视的是reactive素定义的对象中的某个属性，所以deep配置有效     3.watchEffect 函数   watch 的套路是：既要指明监视的属性，也要指明监视的回调。\n  watchEffect 的套路是：不用指明监视哪个属性，监视的回调中用到哪个属性，那就监视哪个属性。\n  watchEffect 有点像 computed：\n 但 computed 注重的计算出来的值（回调函数的返回值），所以必须要写返回值。 而 watchEffect 更注重的是过程（回调函数的函数体），所以不用写返回值。  1 2 3 4 5 6  //watchEffect所指定的回调中用到的数据只要发生变化，则直接重新执行回调。 watchEffect(() =\u0026gt; { const x1 = sum.value; const x2 = person.age; console.log(\u0026#39;watchEffect配置的回调执行了\u0026#39;); });     8.生命周期 1\n Vue3.0 中可以继续使用 Vue2.x 中的生命周期钩子，但有有两个被更名：  beforeDestroy改名为 beforeUnmount destroyed改名为 unmounted   Vue3.0 也提供了 Composition API 形式的生命周期钩子，与 Vue2.x 中钩子对应关系如下：  beforeCreate===\u0026gt;setup() created=======\u0026gt;setup() beforeMount ===\u0026gt;onBeforeMount mounted=======\u0026gt;onMounted beforeUpdate===\u0026gt;onBeforeUpdate updated =======\u0026gt;onUpdated beforeUnmount ==\u0026gt;onBeforeUnmount unmounted =====\u0026gt;onUnmounted    9.自定义 hook 函数   什么是 hook？—— 本质是一个函数，把 setup 函数中使用的 Composition API 进行了封装。\n  类似于 vue2.x 中的 mixin。\n  自定义 hook 的优势: 复用代码, 让 setup 中的逻辑更清楚易懂。\n  10.toRef   作用：创建一个 ref 对象，其 value 值指向另一个对象中的某个属性。\n  语法：const name = toRef(person,'name')\n  应用: 要将响应式对象中的某个属性单独提供给外部使用时。\n  扩展：toRefs 与toRef功能一致，但可以批量创建多个 ref 对象，语法：toRefs(person)\n  三、其它 Composition API 1.shallowReactive 与 shallowRef   shallowReactive：只处理对象最外层属性的响应式（浅响应式）。\n  shallowRef：只处理基本数据类型的响应式, 不进行对象的响应式处理。\n  什么时候使用?\n 如果有一个对象数据，结构比较深, 但变化时只是外层属性变化 ===\u0026gt; shallowReactive。 如果有一个对象数据，后续功能不会修改该对象中的属性，而是生新的对象来替换 ===\u0026gt; shallowRef。    2.readonly 与 shallowReadonly  readonly: 让一个响应式数据变为只读的（深只读）。 shallowReadonly：让一个响应式数据变为只读的（浅只读）。 应用场景: 不希望数据被修改时。  3.toRaw 与 markRaw  toRaw：  作用：将一个由reactive生成的响应式对象转为普通对象。 使用场景：用于读取响应式对象对应的普通对象，对这个普通对象的所有操作，不会引起页面更新。   markRaw：  作用：标记一个对象，使其永远不会再成为响应式对象。 应用场景:  有些值不应被设置为响应式的，例如复杂的第三方类库等。 当渲染具有不可变数据源的大列表时，跳过响应式转换可以提高性能。      4.customRef   作用：创建一个自定义的 ref，并对其依赖项跟踪和更新触发进行显式控制。\n  实现防抖效果：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38  \u0026lt;template\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; v-model=\u0026#34;keyword\u0026#34; /\u0026gt; \u0026lt;h3\u0026gt;{{ keyword }}\u0026lt;/h3\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import { ref, customRef } from \u0026#39;vue\u0026#39;; export default { name: \u0026#39;Demo\u0026#39;, setup() { // let keyword = ref(\u0026#39;hello\u0026#39;) //使用Vue准备好的内置ref  //自定义一个myRef  function myRef(value, delay) { let timer; //通过customRef去实现自定义  return customRef((track, trigger) =\u0026gt; { return { get() { track(); //告诉Vue这个value值是需要被“追踪”的  return value; }, set(newValue) { clearTimeout(timer); timer = setTimeout(() =\u0026gt; { value = newValue; trigger(); //告诉Vue去更新界面  }, delay); } }; }); } let keyword = myRef(\u0026#39;hello\u0026#39;, 500); //使用程序员自定义的ref  return { keyword }; } }; \u0026lt;/script\u0026gt;     5.provide 与 inject   作用：实现祖与后代组件间通信\n  套路：父组件有一个 provide 选项来提供数据，后代组件有一个 inject 选项来开始使用这些数据\n  具体写法：\n  祖组件中：\n1 2 3 4 5 6  setup(){ ...... let car = reactive({name:\u0026#39;奔驰\u0026#39;,price:\u0026#39;40万\u0026#39;}) provide(\u0026#39;car\u0026#39;,car) ...... }     后代组件中：\n1 2 3 4 5 6  setup(props,context){ ...... const car = inject(\u0026#39;car\u0026#39;) return {car} ...... }       6.响应式数据的判断  isRef: 检查一个值是否为一个 ref 对象 isReactive: 检查一个对象是否是由 reactive 创建的响应式代理 isReadonly: 检查一个对象是否是由 readonly 创建的只读代理 isProxy: 检查一个对象是否是由 reactive 或者 readonly 方法创建的代理  四、Composition API 的优势 1.Options API 存在的问题 使用传统 OptionsAPI 中，新增或者修改一个需求，就需要分别在 data，methods，computed 里修改 。\n2.Composition API 的优势 我们可以更加优雅的组织我们的代码，函数。让相关功能的代码更加有序的组织在一起。\n五、新的组件 1.Fragment  在 Vue2 中: 组件必须有一个根标签 在 Vue3 中: 组件可以没有根标签, 内部会将多个标签包含在一个 Fragment 虚拟元素中 好处: 减少标签层级, 减小内存占用  2.Teleport   什么是 Teleport？—— Teleport 是一种能够将我们的组件 html 结构移动到指定位置的技术。\n1 2 3 4 5 6 7 8  \u0026lt;teleport to=\u0026#34;移动位置\u0026#34;\u0026gt; \u0026lt;div v-if=\u0026#34;isShow\u0026#34; class=\u0026#34;mask\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;dialog\u0026#34;\u0026gt; \u0026lt;h3\u0026gt;我是一个弹窗\u0026lt;/h3\u0026gt; \u0026lt;button @click=\u0026#34;isShow = false\u0026#34;\u0026gt;关闭弹窗\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/teleport\u0026gt;     3.Suspense   等待异步组件时渲染一些额外内容，让应用有更好的用户体验\n  使用步骤：\n  异步引入组件\n1 2  import { defineAsyncComponent } from \u0026#39;vue\u0026#39;; const Child = defineAsyncComponent(() =\u0026gt; import(\u0026#39;./components/Child.vue\u0026#39;));     使用Suspense包裹组件，并配置好default 与 fallback\n1 2 3 4 5 6 7 8 9 10 11 12 13  \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;h3\u0026gt;我是App组件\u0026lt;/h3\u0026gt; \u0026lt;Suspense\u0026gt; \u0026lt;template v-slot:default\u0026gt; \u0026lt;Child /\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;template v-slot:fallback\u0026gt; \u0026lt;h3\u0026gt;加载中.....\u0026lt;/h3\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/Suspense\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt;       六、其他 1.全局 API 的转移   Vue 2.x 有许多全局 API 和配置。\n  例如：注册全局组件、注册全局指令等。\n1 2 3 4 5 6 7 8 9 10 11 12  //注册全局组件 Vue.component(\u0026#39;MyButton\u0026#39;, { data: () =\u0026gt; ({ count: 0 }), template: \u0026#39;\u0026lt;button @click=\u0026#34;count++\u0026#34;\u0026gt;Clicked {{ count }} times.\u0026lt;/button\u0026gt;\u0026#39; }) //注册全局指令 Vue.directive(\u0026#39;focus\u0026#39;, { inserted: el =\u0026gt; el.focus() }       Vue3.0 中对这些 API 做出了调整：\n 将全局的 API，即：Vue.xxx调整到应用实例（app）上    2.x 全局 API（Vue） 3.x 实例 API (app)     Vue.config.xxxx app.config.xxxx   Vue.config.productionTip 移除   Vue.component app.component   Vue.directive app.directive   Vue.mixin app.mixin   Vue.use app.use   Vue.prototype app.config.globalProperties        2.其他改变   data 选项应始终被声明为一个函数。\n  过度类名的更改：\n  Vue2.x 写法\n1 2 3 4 5 6 7 8  .v-enter, .v-leave-to { opacity: 0; } .v-leave, .v-enter-to { opacity: 1; }     Vue3.x 写法\n1 2 3 4 5 6 7 8 9  .v-enter-from, .v-leave-to { opacity: 0; } .v-leave-from, .v-enter-to { opacity: 1; }       移除keyCode 作为 v-on 的修饰符，同时也不再支持config.keyCodes\n  移除v-on.native修饰符\n  父组件中绑定事件\n1 2 3 4  \u0026lt;my-component v-on:close=\u0026#34;handleComponentEvent\u0026#34; v-on:click=\u0026#34;handleNativeClickEvent\u0026#34; /\u0026gt;     子组件中声明自定义事件\n1 2 3 4 5  \u0026lt;script\u0026gt; export default { emits: [\u0026#39;close\u0026#39;] }; \u0026lt;/script\u0026gt;       移除过滤器（filter）\n 过滤器虽然这看起来很方便，但它需要一个自定义语法，打破大括号内表达式是 “只是 JavaScript” 的假设，这不仅有学习成本，而且有实现成本！建议用方法调用或计算属性去替换过滤器。\n   \u0026hellip;\u0026hellip;\n  ","date":"2022-05-14T00:00:00Z","permalink":"https://example.com/2022/vue3/","title":"Vue3"}]