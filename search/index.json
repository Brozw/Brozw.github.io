[{"content":" 类可以被认为是一种自定义的数据类型，可以使用类定义变量，但变量类型都是引用类型，引用（指向）类的实例，类用来描述客观世界里的某一类对象的共同特征，而对象是类的具体存在，java程序实用类的构造器创建类实例，类主要用于：定义变量，创建对象，调用类的类方法或类变量\n 定义类 1 2 3 4 5 6  [修饰符] class 类名 { 零或多个构造器定义； 零或多个成员变量定义； 零或多个方法定义； }   将类看作自定义数据类型，就是除了8种基本类型以外的其他类型，用于表示和处理基本类型以外的其他数据。一个数据类型由其包含的属性以及该类型可以进行的操作组成，属性又可以分为是类型本身具有的属性，还是一个具体实例具有的属性，同样，操作也可以分为是类型本身可以进行的操作，还是一个具体实例可以进行的操作。\n❑ 类型本身具有的属性，通过类变量体现\n❑ 类型本身可以进行的操作，通过*类方法*体现\n❑ 类型实例具有的属性，通过*实例变量*体现\n❑ 类型实例可以进行的操作，通过*实例方法*体现\n类变量和实例变量都叫成员变量，也就是类的成员，类变量也叫静态变量或静态成员变量。类方法和实例方法都叫成员方法，也都是类的成员，类方法也叫静态方法。\n类成员 构造器  特殊的方法，来确保类实例初始化\n 1 2 3  [修饰符] 构造器名(形参列表){ 执行体 }     修饰符：可省，public,protected,private其一\n  构造器名：必须与类型相同\n==注意==没有定义构造器，系统会默认提供一个无形参列表的构造器\n  成员变量 1  [修饰符] 类型 成员变量名 = 初始值；     修饰符：可省，public,protected,private,static,final.public,protected,private出现其一，可以static,final进行组合\n  类型：任意数据类型\n  方法 1 2 3  [修饰符] 返回值类型 方法名(形参列表){ 执行体 }     修饰符：可省，public,protected,private,static,final,abstract public,protected,private出现其一，final,abstract出现其一，可以static进行组合\n==注意==static修饰方法，成员变量，等成员，修饰的成员表明它属于类本身，不属于类的单个实例，也称静态，静态成员不能直接访问非静态成员\n  返回值类型 ：任何数据类型,基本和引用，有且仅有一个\n  方法名：描述实例行为特征或功能实现，建议以动词开头\n  形参列表：由零组或多组\u0026quot;参数类型 形参名\u0026quot;组合而成，多组参数之间用逗号隔开，形参类型与形参名以英文空格隔开，一旦定义方法时指定形参列表，调用方法时必须传入对应的参数值，谁调用方法，谁负责为形参赋值\n  执行体是顺序结构\n  方法要求有返回数据类型，则方法体中最后的执行语句必须为 return 值;返回值类型必须和 return 的值类型一致或兼容，如果方法是 void，则方法体中可以没有 return 语句，或者只写return ;\n  方法属于对象或类\n  执行方法必须是类或对象\n  方法作用   应付复杂情况\n  隐藏底层细节\n   重复使用代码  方法调用 main访问可以调用其他所有方法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  public class MethodDetail02 { public static void main(String[] args) { A a = new A(); //a.sayOk();  a.m1(); } } class A { //同一个类中的方法调用：直接调用即可  public void print(int n) { System.out.println(\u0026#34;print()方法被调用 n=\u0026#34; + n); } public void sayOk() { //sayOk 调用 print(直接调用即可)  print(10); System.out.println(\u0026#34;继续执行 sayOK()~~~\u0026#34;); } //跨类中的方法 A 类调用 B 类方法：需要通过对象名调用  public void m1() { //创建 B 对象, 然后在调用方法即可  System.out.println(\u0026#34;m1() 方法被调用\u0026#34;); B b = new B(); b.hi(); System.out.println(\u0026#34;m1() 继续执行:)\u0026#34;); } } class B { public void hi() { System.out.println(\u0026#34;B 类中的 hi()被执行\u0026#34;); } }   调用机制 参数传递 基本数据类型 引用数据类型 java的参数传递方式只有一种：值传递，将实际参数值的副本传入方法中\n形参可变 java允许定义形参个数可变的参数，从而允许为方法指定数量不确定的形参，在最后一个形参类型的类型后添加三点(…),表明该形参接收多个参数值，多个参数值被当做数组传入\n1 2 3 4 5 6 7 8 9 10 11 12  public static void test(int ...numbers) { for(int temp:numbers) {//numbers被当做数组处理int[]numbers  System.out.print(temp); } } public static void main(String[] args){ test(1,2,3); System.out.print(\u0026#34;\\n\u0026#34;); test(1,2,3,4); }// 123 1234   ==注意==可数可变的形参只能处于形参列表最后，一个方法中有且仅有一个个数可变的形参\n递归 一个方法的方法体实现再次调用方法本身\n重载 方法名相同，形参列表不同\nJava 允许一个函数具有相同的名称，通过参数的数量和类型来区分\n1 2 3  float divide(int a, int b){...} float divide( float x, float y){...} float divide( float x, int y){...}   对象 产生对象的根本途径是构造器，通过new关键字\n1 2  Person p;//person类是自定义数据类型 p = new Person();//调用person类构造器保证p的初始化   不管是数组还是对象，都只能通过引用访问，，程序访问引用引用变量的成员方法或变量时，实际是访问该因引用变量所应用的数组，对象的成员变量或方法\n==引用==实际就是给对象提供一个替代的名字\n对象创建流程 this引用 this总是指向调用该方法的对象,this还可以调用方法，属性\n 构造器中使用this指向构造器正在初始化的对象 方法中调用指向调用该方法的对象  1 2 3 4 5 6 7 8 9 10 11 12  public class Apple { int i = 0; Apple eatApple(){ i++; return this; } public static void main(String[] args){ Apple apple = new Apple(); apple.eatApple().eatApple(); } }// eatApple()可以被无限调用   通常来说，一个方法访问所在类的其他方法，成员变量，有无this效果一致,类的所有实例都拥有所在类的其他方法，成员变量\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  public class Apple { public void jump(){ System.out.println(\u0026#34;jump\u0026#34;); } public void run(){ System.out.println(\u0026#34;run\u0026#34;); jump();//无this  this.jump();//this指向调用对象apple  } public static void main(String[] args){ Apple apple = new Apple();//创建Apple对象apple  apple.run(); } } // run jump jump   ==static修饰的方法中调用普通方法，需要创建对象调用，static表示类本身，不可以在static方法中使用this，this指实例==\n一个类有多个构造器，this会对于自变量列表相符的构造器进行调用,this出现在首行\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  public class Apple { private int num; private String color; public Apple(int num) { this(num, \u0026#34;red\u0026#34;); } public Apple(String color) { this(1, color); } public Apple(int num, String color) { this.num = num; this.color = color; } }   ","date":"2022-05-20T00:00:00Z","permalink":"https://example.com/2022/11.%E7%B1%BB/","title":"11.类"},{"content":"封装 将对象的状态信息（成员变量和方法）隐藏在对象内部，不允许外部访问，而是通过该类提供的方法来实现对类内部的操作和访问\n实现方式  将类的变量声明为 private，这样就不能直接从类外部访问它们 提供声明为 public 的 setter 和 getter 方法，以操作和访问变量的值。  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54  public class Encapsulation { //Declaring the variables as private  private String techVidvanName; private String techvidvanProfile; private int techVidvanAge; //declaring \u0026#39;public\u0026#39; Setter and Getter Methods  public void setName(String techVidvanName) { this.techVidvanName = techVidvanName; } public String getName() { return techVidvanName; } public void setProfile(String techVidvanProfile) { this.techvidvanProfile = techVidvanProfile; } public String getProfile() { return techvidvanProfile; } public void setAge(int techVidvanAge) { this.techVidvanAge = techVidvanAge; } public int getAge() { return techVidvanAge; } public static void main (String[] args) { Encapsulation obj = new Encapsulation(); // setting values of the variables through setter methods  obj.setName(\u0026#34;Avina Garg\u0026#34;); obj.setAge(22); obj.setProfile(\u0026#34;Research Analyst Intern\u0026#34;); // Displaying values of the variables through Getter methods  System.out.println(\u0026#34;Name of the employee: \u0026#34; + obj.getName()); System.out.println(\u0026#34;Age of the employee: \u0026#34; + obj.getAge()); System.out.println(\u0026#34;Profile of the employee: \u0026#34; + obj.getProfile()); } }// Name of the employee: Avina Garg Age of the employee: 22 Profile of the employee: Research Analyst Intern   ==抽象与封装的区别==\n 抽象，是指从众多的事物中抽取出具有共同的、本质性的特征作为一个整体。是共同特质的集合形式。\n 封装，是将通过抽象所得到的数据信息和操作进行结合，使其形成一个有机的整体。对内执行操作，对外隐藏细节和数据信息。\n包 包类似于文件夹，主要用于组织类和接口。\n  区分同名的类\n  控制访问权限\n  方便管理类\n  访问控制符 java 提供四种访问控制修饰符号，用于控制一个类的成员是否能被其他类访问\n 公开级别:用 public 修饰,对外公开 受保护级别:用 protected 修饰,对子类和同一个包中的类公开 默认级别:没有修饰符号,向同一个包的类公开 私有级别:用 private 修饰,只有类本身可以访问,不对外公开  ==注意==\n java源文件里定义的所有类都没有使用public修饰，java源文件的文件名可以是任意，但只要定义了一个public修饰的类，原文件的文件名必须与public修饰的类名相同  ==建议==\n 类成员变量都应该使用private修饰，辅助实现该类的其他的方法的方法也应该使用private修饰 某个类主要做其他类的父类，该类的方法可能仅希望被子类进行重写，而不想被外部调用，使用protected修饰 暴露给其他类自由调用使用public修饰，所以类的构造器使用public修饰以便于在其他类中创建实例，大部分外部类public修饰  继承 每个子类与派生它的类具有共同的特征\n 表达继承关系的能力确保了与现实世界模型的紧密性 可重用性，可以从现有类派生一个新类(子类) ，并向其添加新特性，而不必修改其父类。没有必要为了继承它而重写父类 可传递性，如果类 a 继承了另一个类 b 的属性，那么 a 的所有子类都将自动继承来自 b 的属性。这个性质称为继承的传递性  术语  Class： 类是 Java 中用户定义的数据类型，基本上是一组对象。它是我们用来创建对象的蓝图或模板 Super Class：其特性和功能被继承或使用的类称父类 Sub Class： 从另一个类继承属性和特性的类称为子类，子类可以添加自己的特性和函数，也可以添加其父类的字段和方法。 The extends keyword：关键字 extends 由子类继承父类时使用 The super keyword: super 关键字类似于这个关键字。  使用 super 关键字的一些例子:  子类方法中调用父类被覆盖的方法（或者通过类名调用） 从子类调用父类构造函数      ==注意==\n this不可以出现在static修饰的方法，super也不可以，static修饰表示调用者是类或者对象，super调用者为父类实例 不管有无使用super调用父类构造器，子类构造器总会调用父类构造器一次 父类无默认构造器（无形参构造器），子类构造器执行体第一行必须显性调用super()并给出参数定位父类合适的构造器 子类构造器执行体的第一行代码使用this显性调用该类重载的构造器，根据this调用里传入的实参列表调用本类对应的构造器，在调用父类构造器 子类构造器既没有this有没有super,系统会在执行子类构造器之前调用父类构造器，最大的父级构造器是java.lang.Object类的构造器，也即先执行java.lang.Object类的构造器，再执行父类构造器在执行子类构造器，java.lang.Object类的构造器未输出任何内容  Object类 ==和 equals方法： hashCode 方法  提高具有哈希结构的容器的效率 两个引用，如果指向的是同一个对象，则哈希值肯定一样 两个引用，如果指向的是不同对象，则哈希值是不一样 哈希值主要根据地址号来的！， 不能完全将哈希值等价于地址  toString 方法 默认返回：类名+@+哈希值的十六进制，子类往往重写 toString 方法，用于返回对象的属性信\n方法重写 修改父类同名方法\n 子类与父类的方法名相同，形参列表相同 子类的返回类型比父类类型更小或相等 子类方法声明抛出的异常类比父类更小或相等 子类的访问权限比父类大或相等  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  //Base class class Person { String name = \u0026#34;John\u0026#34;; int age = 17; public void show() { System.out.println(\u0026#34;Student inheriting properties from Person\u0026#34;); } } //child class class Student extends Person { // defining additional properties to child class  int marks = 78; //Subcate  public void show() { System.out.println(\u0026#34;子类重写输出覆盖父类同名方法\u0026#34;); super.show(); } public static void main(String args[]) { Student obj = new Student(); obj.show(); System.out.println(\u0026#34;Name : \u0026#34; + obj.name); System.out.println(\u0026#34;Age : \u0026#34; + obj.age); System.out.println(\u0026#34;Marks : \u0026#34; + obj.marks); } }// 子类重写输出覆盖父类同名方法 Student inheriting properties from Person Name : John Age : 17 Marks : 78   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  class Base { public double size; public String name; public Base(double size, String name) { this.size = size; this.name = name; } } class Sub extends Base { public String color; public Sub(double size, String name,String color) { super(size, name); this.color = color; } public static void main(String[] args){ Sub s = new Sub(5.6,\u0026#34;测试\u0026#34;,\u0026#34;红色\u0026#34;); System.out.println(s.size); } }   多态  一个类的方法有不同的形式实现却暴露一个接口（子类方法或子类重写方法），实例方法调用基于运行时实际类型动态调用（引用变量类型在运行时由实际赋给该变量的对象决定），而非声明类型，体现为子类实现功能扩展，父类不修改代码，父类引用变量指向子类对象\n 方法重写/重写就是一种多态\n==注意==\n对象多态的前提是：两个对象(类)存在继承关系\n向上转型 子类为什么可以赋给父类 1.创建子类对象的时候，子类构造器中默认调用父类无参数的构造方法，而且位于方法中的第一条语句。所以创建子类对象的时候先创建父类对象。\n2.内存图\n向下转型 ==注意==\n在使用向下转型时尽量使用instanceof判断用于判断对象的运行类型是否为 XX 类型或 XX 类型的子类型\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  public class Animal { public void cry() { System.out.println(\u0026#34;Animal cry() 动物在叫....\u0026#34;); } } class Cat extends Animal { public void cry() { System.out.println(\u0026#34;Cat cry() 小猫喵喵叫...\u0026#34;); } } class Dog extends Animal { public void cry() { System.out.println(\u0026#34;Dog cry() 小狗汪汪叫...\u0026#34;); } } class PolyObject { public static void main(String[] args) { //体验对象多态特点 //animal 编译类型就是 Animal , 运行类型 Dog  Animal animal = new Dog(); //因为运行时 , 执行到改行时，animal 运行类型是 Dog,所以 cry 就是 Dog 的 cry  animal.cry(); //小狗汪汪叫 //animal 编译类型 Animal,运行类型就是 Cat  animal = new Cat(); animal.cry(); //小猫喵喵叫  } }   ","date":"2022-05-20T00:00:00Z","permalink":"https://example.com/2022/12.%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81/","title":"12.三大特征"},{"content":" 在连续的内存空间中，存储相同类型（基本或引用）的元素，==数组也是一种类型==，适合读O(1)，不适合写（复杂度O(N)）\n 定义方式 1  type[] arrayName;   ==arrayName是引用变量，指向有效内存，由于定义时未指定，所以不能指定数组长度==\n初始化 静态初始化 1  type[] arrayName = { }   根据所给元素数目分配相应数量的内存空间\n动态初始化 1 2  int length = ……//根据某种条件指定长度 type[] arrayName = new type [length]   根据长度分配相应数量的内存空间并分配默认值，等待初始化\n默认值\n 整形：0 浮点：0.0 字符：\u0026rsquo;\\u0000' Boolean:false 引用：null  内存表示 Java 内存的结构分析\n 栈： 一般存放基本数据类型(局部变量) 堆： 存放对象(Cat cat , 数组等) 方法区：常量池(常量，比如字符串)， 类加载信息  1  int[] p = {1,2,3}   ==注意：==一个基本类型变量，内存中只会有一块对应的内存空间。但数组有两块：一块用于存储数组内容本身，另一块用于存储内容的位置。\n数组赋值机制 1 2  int[] arr1 = {1,2,3}; int[] arr2 = arr1;   常见操作 1 2  import java.util.ArrayList; import java.util.Arrays;   创建数组 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  public static void main(String[] args) { // 已知数组元素1  int[] a = {1, 2, 3}; System.out.println(\u0026#34;a:\u0026#34; + Arrays.toString(a)); // 已知数组元素2  int[] b = new int[]{1, 2, 3}; System.out.println(\u0026#34;b:\u0026#34; + Arrays.toString(b)); // 已知数组长度,添加元素  int[] c = new int[3]; for (int i = 0; i \u0026lt; c.length; i++) { c[i] = i + 1; } System.out.println(\u0026#34;c:\u0026#34; + Arrays.toString(c)); // Integer是int对象类型,无需知道长度或元素  ArrayList\u0026lt;Integer\u0026gt; arr = new ArrayList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; 3; i++) { arr.add(i + 1); } System.out.println(\u0026#34;arr:\u0026#34; + arr); } // a:[1, 2, 3] b:[1, 2, 3] c:[1, 2, 3] arr:[1, 2, 3]   添加元素 1 2 3 4  System.out.println(\u0026#34;arr:\u0026#34; + arr); // add添加元素，默认在末尾,O(1)或O(n)(空间不足)  arr.add(99); System.out.println(\u0026#34;arr:\u0026#34; + arr);   访问元素 1 2 3 4 5 6 7 8 9  // 访问元素通过下标  int c1 = c[1]; // arrlist创建数组通过get来访问数组  int arr1 = arr.get(1); System.out.println(\u0026#34;c1:\u0026#34; + c1); System.out.println(\u0026#34;arr1:\u0026#34; + arr1); // c1:2 arr1:2   更新元素 1 2 3 4 5 6 7 8  // 直接更新或set方法，第一个参数索引位置，第二参数为预更新值  c[1] = 11; arr.set(1,11); System.out.println(\u0026#34;c1:\u0026#34; + c[1]); System.out.println(\u0026#34;arr1:\u0026#34; + arr.get(1)); // c1:11 arr1:11   删除元素 1 2 3 4 5  // remove参数索引位置O(n)  arr.remove(1); System.out.println(\u0026#34;arr1:\u0026#34; + arr.get(1)); // arr1:3   数组长度 1 2 3 4 5 6 7 8  // 数组长度O(1)  int cSize = c.length; int arrSize = arr.size(); System.out.println(\u0026#34;c length:\u0026#34; + cSize); System.out.println(\u0026#34;arr length:\u0026#34; + arrSize); // c length:3 arr length:3   遍历数组 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  // 遍历数组  for (int i = 0; i \u0026lt; c.length; i++) { int current = c[i]; System.out.println(\u0026#34;c at index\u0026#34; + i + \u0026#34;:\u0026#34; + current); } for (int i = 0; i \u0026lt; arr.size(); i++) { int current = arr.get(i); System.out.println(\u0026#34;arr at index\u0026#34; + i + \u0026#34;:\u0026#34; + current); } // c at index0:1 c at index1:11 c at index2:3 arr at index0:1 arr at index1:3 arr at index2:99   ==foreach循环==\n遍历数组或集合元素，无需获得数组和集合长度，无需根据索引访问数组元素和集合长度，自动遍历\n1 2 3  for (type variableName（项目名） : arrayName （数组名）| collection){ //执行体 }   1 2 3 4 5 6  String[] books ={\u0026#34;1\u0026#34;,\u0026#34;2\u0026#34;}; for(String book : books){ System.out.println(book); }// 1 2   查找元素 1 2 3 4 5 6 7 8 9 10  // 查找元素  for (int j : c) { if (j == 99) { System.out.println(\u0026#34;found 99\u0026#34;); } } boolean is99 = arr.contains(99); System.out.println(\u0026#34;found99?\u0026#34; + is99); //found99?true   数组排序 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  // 数组排序  c = new int[]{2, 3, 1}; arr = new ArrayList\u0026lt;\u0026gt;(); arr.add(2); arr.add(3); arr.add(1); System.out.println(\u0026#34;c:\u0026#34; + Arrays.toString(c)); System.out.println(\u0026#34;arr:\u0026#34; + arr); // 从小到大  Arrays.sort(c); System.out.println(\u0026#34;c:\u0026#34; + Arrays.toString(c)); Collections.sort(arr); System.out.println(\u0026#34;arr:\u0026#34; + arr); // 从大到小：方式1倒着读，方式2int[] c =\u0026gt; Integer[] c,arr是对象类型sort方法  arr.sort(Collections.reverseOrder()); System.out.println(\u0026#34;arr:\u0026#34; + arr); // c:[2, 3, 1] arr:[2, 3, 1] c:[1, 2, 3] arr:[1, 2, 3] arr:[3, 2, 1]   时间复杂度 访问O(1)\n搜索O(N)\n插入O(N)\n删除O(N)\nN代表数组长度\nO(N)代表最坏情况\n多维数组 由于数组也是一种类型，数组定义type[] arrayName;所以当数组元素为引用（一维数组）时，即多维数组，以二维数组为例：\n1  type[][] arrayName;   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  public static void main(String[] args) { int[][] a; // arrName = new type[length][]  a = new int[4][]; for (int i = 0; i \u0026lt; a.length; i++) { System.out.println(a[i]); } a[0] = new int[2]; a[0][1] = 6; for (int i = 0, len = a[0].length; i \u0026lt; len; i++) { System.out.println(a[0][i]); } }// null null null null 0 6   Array类 导包\n1  import java.util.Arrays   P_100\n","date":"2022-05-19T00:00:00Z","permalink":"https://example.com/2022/10.%E6%95%B0%E7%BB%84/","title":"10.数组"},{"content":"Java 起源 1990 年代初，Sun 公司预计嵌入式系统会在家电领域出色，成立由詹姆斯·高斯林主导的“Green 计划”，目标设置在家用电器等小型系统的编程语言，应用在电视机、电话、闹钟、烤面包机等家用电器的通用控制和通信\n1992 年夏天，Green 计划实现了 Green 操作系统，Oak 程序设计语言等，同年 11 月，Green 计划被转化为 Sun 公司的一个全资子公司“FirstPerson 有限公司”\n1994 年夏天，由于互联网兴起，詹姆斯·高斯林对 Oak 进行改造，同年秋，完成了第一个 Java 语言的网页浏览器：WebRunner,Sun 公司给予高度评价，由于 Oak 商标已被注册，改名为 Java\n1995 年初，正式发布\n1996 年初，Sun 发布 JDK1.0 包括运行环境（JRE1)，开发环境（JDK2）\n1997 年 2 月 18 日，Sun 发布 JDK1.1,增加 JIT(即时编译3)编译器\n1998 年 12 月，Sun 发布 JDK1.2、JSP/Servlet、EJB 等规范，将 Java 分为 J2EE4、J2SE5、J2ME6，并将 API 分为核心 API，可选 API，特殊 API\n2002 年 2 月，Sun 发布 JDK1.4,可以实现大多数应用\n2004 年 10 月，Sun 发布 JDK1.5，改名为 Java SE5.0,增加泛型，增强型 for 循环语句等功能\n2009 年，Sun 公司被 Oracle 收购\n详情\n  JVM+核心类库（解释 class 文件）\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n JRE+编译工具（javac 等命令）\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n 传统编译器编译一条指令运行结束会将其销毁，JIT 编译器会将常用的指令保存在内存中，下次调用不需要再次编译\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n 主要控制移动设备和信息家电优先存储的设备\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n Java 技术的核心和基础\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n Java 应用最广泛的地方\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   ","date":"2022-05-14T00:00:00Z","permalink":"https://example.com/2022/1.%E8%B5%B7%E6%BA%90/","title":"1.起源"},{"content":"高级语言程序设计执行方式 编译型 通过专门的编译器针对特定的操作系统先一次性将高级语言源代码解释转成**平台硬件执行的机器码（机器指令1和操作数2），并包装成该平台所能识别的可执行程序**格式，之后直接运行可执行文件，转换过程称为：编译，编译生成的可执行文件可以脱离开发环境执行，运行效率高，但移植性较差，需要将源代码复制到另一个平台通过该平台特定的编译器重新编译\n解释型 通过专门的解释器对源代码进行解释成特定平台的机器码并立即执行，相当与编译和运行同时进行，也等同于每次执行程序都需要编译，运行效率低，移植性较强，只需提供特定平台的解释器，\nJava 运行机制与 JVM 运行机制 Java 编写的程序\n 编译器生成字节码（*class 文件） 由特定平台的解释器解释运行字节码文件  JVM Java 虚拟机，运行 Java 字节码文件\n_ 重点_\n编译器面向 JVM，不同平台具备不同的 JVM,但编译器提供相同的接口连接不同平台平台的 JVM 来运行字节码文件\n  机器语言是用二进制代码表示的、计算机能直接识别和执行的一种机器指令的集合\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n 操作数（operand)，是 计算机指令中的一个组成部分，它规定了指令中进行数字运算的量\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   ","date":"2022-05-14T00:00:00Z","permalink":"https://example.com/2022/2.%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/","title":"2.运行机制"},{"content":"命令 编译命令：java\n运行命令：javac\n在使用这两个命令之前，需要配置环境变量（一系列路径），使得操作系统通过环境变量查找到命令从而执行\nMac 配置环境变量\n用法 Javac 命令用法： 1  javac -d destdir srcFile   -d destdir:字节码存放路径(可省)\nsrcFile：源文件所在位置\n1  javac -d . Hello.java   .表示当前路径\n注意\n编译后每个类都会生成对应的 class 文件，因为编译生成字节码文件默认以类名为文件名，一个源文件有多个类，则会产生多个字节码文件\njava 命令用法 1  java 类名   ","date":"2022-05-14T00:00:00Z","permalink":"https://example.com/2022/3.%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/","title":"3.配置环境变量"},{"content":"面向对象程序设计 采用面向对象设计，最小程序单元是类，可以生成系统中多个对象，\n类 （狗）\n代表客观世界中具有某种特征的一类事物，面向对象使用类来封装一类事物的内部状态数据（属性）（name），类会提供操作属性的方法,为这类事物的行为特征(run)提供相应的实现\n 属性+方法 = 类\n 对象 （哈士奇）\n类的具体实例\n基本特征 封装 将对象的实现细节隐藏，暴露公用方法来实现该对象功能\n继承 子类继承父类，获得父类的属性和方法多态 子类对象可以直接赋给父类变量，运行时表现出子类的行为特征，即同一个类型对象（父类）在执行同一个方法会有多种行为特征（子类or父类）\n功能  对象基本特点：标识唯一、分类性、多态性、封装、模块 类是具有共同属性、方法的一类事物，类是对象的抽象，通过封装，高内聚，低耦合  关于高内聚与低耦合\n 对象之间相互合作的机制称为“消息”，实例之间互相通信的机制 类之间共享属性和操作的机制成为继承，继承有传递性（属性和方法），单继承（一个直接父级）+多继承（多个直接父级）  ","date":"2022-05-14T00:00:00Z","permalink":"https://example.com/2022/4.%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/","title":"4.面向对象程序设计"},{"content":"单行注释：//\n多行注释：/* */\n文档注释：/** */\n***注意：***文档注释可以被JDK提供的工具javadoc解析生成HTML的说明文档，通常说明了每个类，每个方法的功能及用法\n详见P44\n","date":"2022-05-14T00:00:00Z","permalink":"https://example.com/2022/5.%E6%B3%A8%E9%87%8A/","title":"5.注释"},{"content":" 变量是程序的基本组成单位\n  所有变量必须先声明后使用 相同类型的变量之间允许赋值  声明方式 1 2 3 4  type varName = 初始值 int x = 100;   类型 基本数据和引用数据\n引用数据类型\n对一个对象的引用（指针）\n基本数据类型  整数类型：byte，short，int，long(存放整数值) 浮点数类型：float，double（存放小数） 字符类型：char（表示单个字符，用单引号包住，字符串使用双引号） 布尔类型：boolean（真or假）  字节数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  ┌───┐ byte │ │ └───┘ ┌───┬───┐ short │ │ │ └───┴───┘ ┌───┬───┬───┬───┐ int │ │ │ │ │ └───┴───┴───┴───┘ ┌───┬───┬───┬───┬───┬───┬───┬───┐ long │ │ │ │ │ │ │ │ │ └───┴───┴───┴───┴───┴───┴───┴───┘ ┌───┬───┬───┬───┐ float │ │ │ │ │ └───┴───┴───┴───┘ ┌───┬───┬───┬───┬───┬───┬───┬───┐ double │ │ │ │ │ │ │ │ │ └───┴───┴───┴───┴───┴───┴───┴───┘ ┌───┬───┐ char │ │ │ └───┴───┘   表示范围 整型（最高位的bit表示符号位（0表示正数，1表示负数）\n浮点型（最高位符号位，接下来8/11位表示指数，接下来23/52位表示尾数）\n使用细节  数据类型所占字节数不受操作系统发生改变 整型常量默认为int，不足在后加L 1字节8位 浮点数=符号位+指数位+尾数位，尾数部分可能丢失，造成精度损失(小数都是近似值）详情 转义字符 详情,char输出转义字符会表示转义 char的本质是整数，对应Unicode码字符 字符型表现形式：单个字符+转义字符+Unicode值 char存储：a=\u0026gt;97=\u0026gt;二进制=\u0026gt;存储 char输出：二进制=\u0026gt;97=\u0026gt;a=\u0026gt;显示 规定浮点数二进制表示= 1.XXX x 2N，有效数字223=8388608（7位数） 小数默认以double存放，若想让编译器理解成float在之后f 定义32位的二进制整数，最高位为符号位，符号位1位为负，数字以补码形式存在，换算成原码（十进制的二进制码），负数的补码=反码+1，正数的原码与补码相同，反码指最高位不变，其他位取反  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  //字符型 public class Basic { public static void main(String[] args) { char word = 97; System.out.println(word); /* 输出为a,本质为整数，在内存中存储为整数 输出所给整数对应的Unicode编码字符 */ int word3 = \u0026#39;a\u0026#39;; System.out.println(word3);//输出为97  char word1 = \u0026#39;\\r\u0026#39;; System.out.println(word1);//输出为回车  char word2 = \u0026#39;a\u0026#39;; System.out.println(word2);//输出为a  } }   浮点数细节 进制转换 对照表格 原理 简单方法 精度损失 科学计数法 IEEE754  单精度够用就不要用双精度，浪费空间  浮点数的限制 最高位为符号位（+，-）\n小数位存放省去整数位的1的有效二进制位\n指数位偏移127（+127/1023）来表示\n补充 0.1+0.2!=0.3\n二进制运算方法\n正无穷大、负无穷大、非数？\n原码、反码、补码\n基本数据类型的转换 自动类型转换 箭头左边的数值类型可以自动类型转换为箭头右边的数值类型\n1 2 3 4 5 6 7 8 9  public class Basic { public static void main(String[] args) { int a = 6; float b = a;//输出6.0  System.out.println(b); System.out.println(1+2+\u0026#34;Hello\u0026#34;);//输出3Hello  System.out.println(\u0026#34;Hello\u0026#34;+1+2);//输出Hello12  } }   +：加法运算符和字符串连接符\n强制类型转换 1 2  (targettype)value 将value转换成目标类型   箭头右边的转换成箭头左边的\n1 2 3 4 5 6 7  public class Basic { public static void main(String[] args) { int value = 233; byte value1 = (byte)value; System.out.println(value1);//输出-23  } }   1 2 3 4 5 6 7 8 9  //产生随机数 public static void main(String[] args) { String result = \u0026#34;\u0026#34;; for (int i = 0; i \u0026lt;6;i++){ int ran = (int)(Math.random()*26+97);//取整  result = result + (char)ran;//取整对应字符  } System.out.println(result); }   注意\n小数默认为double\n1  double = double(5.6)   表达式的类型提升  所有的byte,short,char类型会被提升至int 算数表达式的数据类型自动提升至表达式中最高等级操作数同样的类型  1 2 3 4 5 6 7 8  public static void main(String[] args) { byte b = 3; char c = \u0026#39;a\u0026#39;; int i = 10; double d = .05; double e = b + c + i * d;//100.5提升至d  System.out.println(e); }   1 2  short a = 5; short b = a*5;//出错，int_short   ","date":"2022-05-14T00:00:00Z","permalink":"https://example.com/2022/6.%E5%8F%98%E9%87%8F%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","title":"6.变量与数据类型"},{"content":"运算符 算数运算符  数学表达式或算术计算\n 加法  加法运算符，字符串连接符\n 算术二元运算符(+)将其操作数的值相加，结果是其两个操作数值的和。它的操作数可以是整数类型(int、 short、 byte、 long、 double)或者 浮点类型(float 和 double)\n减法  减法运算符，求负运算符(单目运算符)\n 减法运算符(-)从第一个操作数中减去第二个操作数。操作数可以是整型或浮点型\n乘法 乘法运算符(*)对其操作数的值进行乘法。操作数可以是整型或浮点型\n除法 除法运算符(/)对其操作数的值进行除法，操作数可以是整数类型或浮点类型\n注意：\n 除法操作符的两操作数都为整数，计算结果为整数，按照自然除法的结果截断取整 操作数都为整型，除数不能为0，会报异常 操作数有一个是浮点数或都是，则计算结果也是浮点数，允许除数为0或0.0，得到结果为正无穷大或负无穷大  1 2 3 4 5 6 7 8 9  public static void main(String[] args) { int a = 1; int b = 2; double c = 2.5; double d = 0.5; System.out.println(a/b);//0  System.out.println(c/d);//5.0  System.out.println(c/0.0);//Infinity  }   求余 求余运算符(%)\n模算符% 求出了它的第一个操作数相对于第二个操作数的模，生成结果整数后的其余部分\n注意同除法运算符\n1 2 3 4 5 6 7 8 9  public static void main(String[] args) { double a = 2.5; double b = 0.5; double c = a%b; System.out.println(c); System.out.println(5.0%0);//输出为0，结果非数NAN  System.out.println(0%5.0);//0、0.0对任何数求余结果为0  System.out.println(0%0.0); }   自加  单目运算符 操作数为整型或浮点型，不可以操作表达式或常量，可以出现在操作数的左右，效果不同  ***注意：***只可以运用于变量，不可以运用于操作数值或常量或表达式\n1  num = num + 1 = ++num or num++;   1 2 3 4 5 6 7  public static void main(String[] args) { int a = 2; int b = a++; //后加1先用原值  int c = ++a; //先加1再用  System.out.println(b);//2  System.out.println(c);//4  }   自减 同自加\n赋值运算符  （=）为变量指定值\n  从右到左计算  1 2 3  int a = 2; int b = a; //a赋值b System.out.println(b);   扩展赋值运算符 +=,-=,*=,/=,%=,\u0026amp;=,|=,^=,\u0026laquo;=,\u0026raquo;=,\u0026raquo;\u0026gt;=\n   *Shorthand Operator* *Use* *Equivalent to*     += op1 += op2 op1 = op1 + op2   -= op1 -= op2 op1 = op1 – op2   *= op1 *= op2 op1 = op1 * op2   /= op1 /= op2 op1 = op1 / op2   %= op1 %= op2 op1 = op1 % op2   \u0026amp;= op1 \u0026amp;= op2 op1 = op1 \u0026amp; op2   |= op1 |= op2 op1 = op1 | op2   ^= op1 ^= op2 op1 = op1 ^ op2   \u0026laquo;= op1 \u0026laquo;= op2 op1 = op1 \u0026laquo; op2   \u0026raquo;= op1 \u0026raquo;= op2 op1 = op1 \u0026raquo; op2   \u0026raquo;\u0026gt;= op1 \u0026raquo;\u0026gt;= op2 op1 = op1 \u0026raquo;\u0026gt; op2    位运算符 按位运算符操作数字的各个位。按位运算符使用的整数类型是byte，short，int 和 long 类型。提供了4个按位运算符:\n   *Operator* *Use* *Operation*     \u0026amp; op1 \u0026amp; op2 与   | Op1 | op2 或   ^ op1 ^ op2 异或   ~ ~op2 非   \u0026laquo; op1 \u0026laquo; op2 左移   \u0026raquo; op1 \u0026raquo; op2 右移   \u0026raquo;\u0026gt; op1 \u0026raquo;\u0026gt; op2 无符号右移    \u0026amp;  全1则1，有0则0\n    op1 op2 Result (op1 \u0026amp; op2)     0 0 0   0 1 0   1 0 0   1 1 1    |  有1则1，全0则0\n    op1 op2 Result (op1 | op2)     0 0 0   0 1 1   1 0 1   1 1 1    ^  相同则0，不同则1\n    op1 op2 Result(op1 ^ op2)     0 0 0   0 1 1   1 0 1   1 1 0    ~    *op1* *Result* (~op1)     0 1   1 0    原理 1 2 3 4  public static void main(String[] args) { System.out.println(~-5);//4  System.out.println(5^9);//12 }   位运算符\n右移：\u0026raquo;和\u0026raquo;\u0026gt;区别：填充方式是否按原本的符号位填充\n1 2 3 4  public static void main(String[] args) { System.out.println(-5\u0026gt;\u0026gt;2);//-2  System.out.println(-5\u0026gt;\u0026gt;\u0026gt;2);//1073741822  }   注意   低于int类型的操作数会自动转换成int型\n  int型整数移位a\u0026raquo;b，b\u0026gt;32,系统会将b对32求余，得到结果才是真正移位的位数 a\u0026raquo;33 = a\u0026raquo;1\n  long型整数移位a\u0026raquo;b，b\u0026gt;64,系统会将b对64求余，得到结果才是真正移位的位数\n  左移n位就是乘2^n^，右移n位就是除2^n^\n  比较运算符 判断常量或变量（比较数字和字符），比较之后，它们返回布尔数据类型的结果，如果比较结果为真，那么关系运算的结果为真，否则为假。广泛用于循环以及条件 if-else 语句。\n除== 和 != 其他比较运算符只支持数值比较，= =只要操作数的值相等不管数据类型，都会返回true，比较引用变量时只有操作数互为父子关系才可以比较，这两个引用指向才会返回true，基本类型不能和引用类型的进行= =比较，布尔类型不能和其他任意类型进行比较，引用类型之间没有父子关系，也不可以进行比较，！=同理\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  public static void main(String[] args) { System.out.println(5\u0026gt;4.0); System.out.println(5 ==5.0); System.out.println(97 == \u0026#39;a\u0026#39;); Basic b1 = new Basic(); Basic b2 = new Basic(); System.out.println(b1 == b2); Basic b3 = b2; System.out.println(b2 == b3);//指向相同  } //输出： true true true false true   逻辑运算符 逻辑运算符也称为条件运算符。这些运算符用于计算一个或多个布尔表达式，用于复杂的决策，返回一个布尔值(true 或 false)\n逻辑 AND 运算符(\u0026amp; \u0026amp;)将两个表达式(操作数)组合成一个表达式。只有当结果表达式的两个表达式(操作数)都为真时，结果表达式的计算结果才为真\n逻辑 OR 运算符(| |)还将两个表达式(操作数)组合成一个表达式。如果结果表达式的任何一个表达式(操作数)的计算结果为 true，则结果表达式的计算结果为 true。\n逻辑 NOT 操作符，编写为！，是一元运算符，用于处理单个操作数或表达式。逻辑 NOT 运算符(!)否定或反转其操作数的真值。\n1 2 3 4  (5==3) \u0026amp;\u0026amp; (4==4) //results into false because first expression is false. (4==4) \u0026amp;\u0026amp; (7==7) //results into true because both expressions are true. (6==3) || (4==4) //results into true because second expression is true.  ! (9 != 0) //results into false because 9 is non-zero(i.e., true).   三目运算符 1  expression1 ? expression2 : expression3 ;   整个表达的结果取决于表达的价值。如果表达式1的结果为真即为1，那么表达式2的价值就被计算，否则，表达式3的价值就被计算。例如，result = marks \u0026gt; = 50？“及格”: “不及格”;如果测试表达式 \u0026gt; = 50计算结果为 true (1) ，则变量 result 的值将为“ Pass”，否则，结果的值将为“ Fail”。\n1  6 \u0026gt; 4 ? 9 : 7 evaluates to 9 because test expression 6 \u0026gt; 4 is true.   点运算符 点运算符(.)用于访问类的对象或类成员的实例成员。\n1 2 3 4 5 6 7  class MyClass { int num1=10; public static void main(String args[]){ MyClass object1 = new MyClass(); object1.num1 = 10; //using dot operator  }   （）运算符 在声明或调用方法或函数时使用此运算符。我们可以在圆括号(和)之间列出方法的参数，或者我们可以使用()指定一个空的参数列表，它们之间没有任何东西。\n1 2  void display(); Int addNumbers(int x, int y);   instanceof Instanceof 操作符用于类型检查。它测试它的第一个操作数是否是第二个操作数的实例。它可以用来测试对象是类、子类还是接口的实例并返回布尔值。一般的语法是:\n1  op1 instanceof op2;   运算符优先级 注意：上一行的运算符总是优先于下一行\n","date":"2022-05-14T00:00:00Z","permalink":"https://example.com/2022/7.%E8%BF%90%E7%AE%97%E7%AC%A6/","title":"7.运算符"},{"content":"运算符 分号; 语句的分隔，可以将语句写在同一行，中间以;分隔\n==语句与表达的区别==\n 表达式是可以被求值的代码，而语句是一段可执行代码 表达式可被求值，可写在赋值语句等号的右侧 语句不一定有值，像import、for和break等语句就不能被用于赋值 一个分号代表一个一个空语句  花括号 定义代码块，{}内部存代码块，代码块逻辑上是一个整体，方法体/类定义必须放在代码块中，条件语句的条件执行体和循环体通常也放在代码块中\n方括号[] 访问数组元素，方括号通常紧跟数组变量名，方括号内指定希望访问的数组元素的索引\n点. 点(.)用于访问类的对象或类成员的实例成员。\n1 2 3 4 5 6 7  class MyClass { int num1=10; public static void main(String args[]){ MyClass object1 = new MyClass(); object1.num1 = 10; //using dot operator  }   括号（） 在声明或调用方法或函数时使用此运算符。我们可以在圆括号(和)之间列出方法的参数，或者使用()指定一个空的参数列表，它们之间没有任何东西。同时也是作为强制类型转换的运算符，不因如此，圆括号可以将表达式某个部分括成一个整体保证优先计算\n1 2  void display(); Int addNumbers(int x, int y);   instanceof Instanceof 操作符用于类型检查。它测试它的第一个操作数是否是第二个操作数的实例。它可以用来测试对象是类、子类还是接口的实例并返回布尔值。一般的语法是:\n1  op1 instanceof op2;   ","date":"2022-05-14T00:00:00Z","permalink":"https://example.com/2022/8.%E8%BF%90%E7%AE%97%E7%AC%A6/","title":"8.运算符"},{"content":"流程控制 顺序结构 程序由上到下逐行执行，中间无判断和跳转\n分支结构 if语句使用布尔表达式或布尔值作为分支条件进行分支控制，switch用于对多个整形值进行匹配\nif 形式1\n1 2 3 4  if (条件表达式){ 执行体 } //1个分支   形式2\n1 2 3  if(){} else{} //2个分支   形式3\n1 2 3 4 5  if(){} else if(){} //中间可以有多个else if语句 else{} //多个分支   ==注意==省去{},if只对紧随其后最近的语句进行控制，就近原则\n1 2 3 4 5 6 7 8 9  public static void main(String[] args) { int i = 5; int a = i; if (a \u0026lt; 3) System.out.println(\u0026#34;a\u0026lt;3\u0026#34;); i++; System.out.println(\u0026#34;i加了1\u0026#34;); } //不执行 System.out.println(\u0026#34;a\u0026lt;3\u0026#34;);不对i++进行控制   ==易犯的逻辑错误== else的隐含条件是对if的条件进行取反\n1 2 3 4 5 6 7 8 9 10 11  public static void main(String[] args) { int age = 45; if (age \u0026gt; 20) { System.out.println(\u0026#34;青年\u0026#34;); } else if (age \u0026gt; 40) { System.out.println(\u0026#34;中年\u0026#34;); } else if (age \u0026gt; 60) { System.out.println(\u0026#34;老年\u0026#34;); } } //输出青年   补上else隐含条件\n1 2 3 4 5 6 7 8 9 10  int age = 45; if (age \u0026gt; 20) { System.out.println(\u0026#34;青年\u0026#34;); } if (age \u0026gt; 40 \u0026amp;\u0026amp; !(age \u0026gt; 20)) { System.out.println(\u0026#34;中年\u0026#34;);//永远不会发生 } if (age \u0026gt; 60 \u0026amp;\u0026amp; !(age \u0026gt; 40 \u0026amp;\u0026amp; !(age \u0026gt; 20))) { System.out.println(\u0026#34;老年\u0026#34;);//永远不会发生 }   正确逻辑\n1 2 3 4 5 6 7 8  int age = 45; if (age \u0026gt; 60) { System.out.println(\u0026#34;青年\u0026#34;); } else if (age \u0026gt; 40) { System.out.println(\u0026#34;中年\u0026#34;);//永远不会发生 } else if (age \u0026gt; 20) { System.out.println(\u0026#34;老年\u0026#34;);//永远不会发生 }    使用if……else语句优先把包含范围小的条件放在前面处理，age\u0026gt;60相对于age\u0026gt;40范围更小\n switch 由一个控制语句和多个case标签组成，控制语句数据类型只能为byte,short,char,int四种整数类型，枚举类型和java.lang.String（字符串）类型，不可以是boolean类型，对表达式的值与case值进行匹配，并执行相应case的执行体，break用于跳出执行体，不在执行当前case之后的case的执行体，当表达式与所有case的值都不匹配，执行default\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  switch (表达式){ case(){ 执行体; break; } case(){ 执行体; break; } ....... default: { 执行体; break; } }   循环结构  重复执行某段代码\n  初始化语句：一条或多条语句，在循环之前执行 循环条件：boolean表达式，决定是否执行循环体，真执行 循环体：重复执行的语句 迭代语句：一次循环结束后，对循环条件求求值之前进行，控制循环条件中的变量，使得循环在合适的时间结束  while 1 2 3 4 5  初始化条件 while(循环条件){ 循环体 迭代语句 }   do while 1 2 3 4 5 6  初始化条件 do { 循环体 迭代语句 }while(循环条件);   先执行循环体一次在判断，即do……while至少执行一次\nfor 1 2 3  for (初始化条件;循环条件;迭代语句){ 循环体 }   先执行初始化条件，判断循环条件，真执行循环体，再执行迭代语句，符合循环条件继续循环，知道迭代到不符合条件\n1 2 3 4 5 6 7 8 9  public static void main(String[] args) { for (int i = 0; i \u0026lt; 3; i++) { System.out.println(\u0026#34;Hello\u0026#34;); } } // Hello Hello Hello   for循环允许同时制定多个初始化语句，循环语句可以是一个包含逻辑运算的表达式\n1 2 3 4 5 6 7 8 9  public static void main(String[] args) { for (int a = 0, b = 0, c = 0; a \u0026lt; 2 \u0026amp;\u0026amp; b \u0026lt; 2 || c \u0026lt; 3; a++, b++, c++) { System.out.println(\u0026#34;Hello\u0026#34;); } } // Hello Hello Hello   ==for==:循环条件总比循环体多执行一次，最后一次执行循环条件为false\n==while与for==：指定次数用for，循环条件用while\n==扩大for循环变量作用域==：在for循环中定义的变量，其作用域只在循环内有效，for循环结束，变量销毁，两个解决方法，初始化语句放在循环之前或定义变量来保存循环变量的值，但不可以再次使用当前的循环变量进行新的循环\n1 2 3 4 5 6 7 8 9 10 11 12 13  public static void main(String[] args) { int temp = 0; for (int i = 0; i \u0026lt; 3; i++) { System.out.println(i); temp = i; } System.out.println(temp);//访问循环中i，  } // 0 1 2 2   嵌套循环 外层循环次数为m,内层循环次数为n，总次数为mn\n1 2 3 4 5 6 7  public static void main(String[] args) { for (int i = 0; i \u0026lt; 2; i++) { for(int j = 0; j \u0026lt; 2; j++) { System.out.println(\u0026#34;Hello\u0026#34;); } } }   内层循环将i看做普通变量处理，其值为0，内层循环执行全部次数（判断+迭代），在进行外层循环的迭代语句，\n控制循环  Break:完全结束循环体 continue：结束当前循坏 return：结束一个方法  ==注意==：可以在要结束的循环前打上标签（紧跟一个英文冒号的标识符），来结束特定的循环\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  public static void main(String[] args) { outer: for (int i = 0; i \u0026lt; 2; i++) { for(int j = 0; j \u0026lt; 2; j++) { System.out.println(\u0026#34;Hello\u0026#34;); if (j==1){ break outer; } } } } // Hello Hello   ","date":"2022-05-14T00:00:00Z","permalink":"https://example.com/2022/9.%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/","title":"9.流程控制"},{"content":"[toc]\n提示\ncommand +/-提高降低标题级别\ncommand + /进入源代码模式查看具体代码\n字体样式 代码 1 2 3 4 5 6 7 8  1.*斜体*或_斜体_ （command i) 2.**粗体B) (command B) 3.***加粗斜体*** 4.~~删除线~~ 5.下划线 \u0026lt;u\u0026gt;\u0026lt;/u\u0026gt; (command u) 6.==高亮== command shift h 7.上标^3^ 8.下标~3~   样式 斜体\n粗体\n加粗粗体\n删除线\n下划线==高亮==\ncm^3^\nH~2~O\n分级标题 代码 第一种写法 1 2 3 4  这是一个一级标题 ============================ 这是一个二级标题 --------------------------------------------------   第二种写法 1 2 3 4 5 6  # 一级标题（快捷键command+级别数） ## 二级标题 ### 三级标题 #### 四级标题 ##### 五级标题 ###### 六级标题   超链接 行内式 语法说明： [ ]里写链接文字，( )里写链接地址, ( )中的”“中可以为链接指定 title 属性，title 属性可加可不加。title 属性的效果是鼠标悬停在链接上会出现指定的 title 文字。[链接文字](链接地址 “链接标题”)’这样的形式。链接地址与链接标题前有一个空格\n代码 1 2  欢迎来到[梵居闹市](http://blog.leanote.com/freewalk) 欢迎来到[梵居闹市](http://blog.leanote.com/freewalk \u0026#34;梵居闹市\u0026#34;)   样式 梵居闹市\n参考式 参考式超链接一般用在学术论文上面，或者另一种情况，如果某一个链接在文章中多处使用，那么使用引用 的方式创建链接将非常好，它可以让你对链接进行统一的管理\n语法说明： 参考式链接分为两部分，文中的写法 [链接文字][链接标记]，在文本的任意位置添加[链接标记]:链接地址 “链接标题”，链接地址与链接标题前有一个空格。\n如果链接文字本身可以做为链接标记，你也可以写成[链接文字][] [链接文字]：链接地址的形式，见代码的最后一行。\n代码 1 2 3 4 5 6  我经常去的几个网站[Google][1]、[Leanote][2]以及[自己的博客][3] [Leanote 笔记][2]是一个不错的[网站][]。 [1]:http://www.google.com \u0026#34;Google\u0026#34; [2]:http://www.leanote.com \u0026#34;Leanote\u0026#34; [3]:http://http://blog.leanote.com/freewalk \u0026#34;梵居闹市\u0026#34; [网站]:http://http://blog.leanote.com/freewalk   样式 我经常去的几个网站[Google][1]、[Leanote][2]以及[自己的博客][3] [Leanote 笔记][2]是一个不错的[网站][]。 [1]:http://www.google.com \u0026ldquo;Google\u0026rdquo; [2]:http://www.leanote.com \u0026ldquo;Leanote\u0026rdquo; [3]:http://http://blog.leanote.com/freewalk \u0026ldquo;梵居闹市\u0026rdquo; [网站]:http://http://blog.leanote.com/freewalk\n自动链接 语法说明： Markdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用\u0026lt;\u0026gt;包起来， Markdown 就会自动把它转成链接。一般网址的链接文字就和链接地址一样，例如：\n1 2  \u0026lt;http://example.com/\u0026gt; \u0026lt;address@example.com\u0026gt;   样式 http://example.com/ address@example.com\n==快捷键==\ncommand+k\n锚点 网页中，锚点其实就是页内超链接，也就是链接本文档内部的某些元素，实现当前页面中的跳转。比如我这里写下一个锚点，点击回到目录，就能跳转到目录。 在目录中点击这一节，就能跳过来。还有下一节的注脚。这些根本上都是用锚点来实现的。\n语法描述 在你准备跳转到的指定标题后插入锚点{#标记}，然后在文档的其它地方写上连接到锚点的链接。\n代码 1 2 3  ## 0. 目录{#index} 跳转到[目录](#index){#index}   跳转到参考式\n*** index与标题内容完全一致***\ncommand+鼠标左键\n列表 无序列表 语法描述 使用 *，+，- 表示无序列表,降低基本级别tab，提升级别command+[\n代码 1 2 3  - 无序列表项 - 无序列表项 - 无序列表项   样式  无序列表项 无序列表项 无序列表项 无序列表项  有序列表 语法描述 有序列表则使用数字接着一个英文句点。(command+option+o), tab降低级别\n代码 1 2 3  1. 有序列表项 一 2. 有序列表项 二 3. 有序列表项 三   样式   有序列表项\n  有序列表项\n  有序列表项\n 有序列表项     提示\n待办事项——段落——任务列表\n定义型列表？ 语法说明： 定义型列表由名词和解释组成。一行写上定义，紧跟一行写上解释。解释的写法:紧跟一个缩进(Tab)\n代码： 1 2 3 4 5 6 7 8  Markdown : 轻量级文本标记语言，可以转换成html，pdf等格式（左侧有一个可见的冒号和四个不可见的空格） 代码块 2 : 这是代码块的定义（左侧有一个可见的冒号和四个不可见的空格） 代码块（左侧有八个不可见的空格）   列表缩进 语法说明： 列表项目标记通常是放在最左边，但是其实也可以缩进，最多 3 个空格，项目标记后面则一定要接着至少一个空格或制表符。*+tab\n要让列表看起来更漂亮，你可以把内容用固定的缩进整理好（显示效果与代码一致）：\n  轻轻的我走了， 正如我轻轻的来； 我轻轻的招手， 作别西天的云彩。 那河畔的金柳， 是夕阳中的新娘； 波光里的艳影， 在我的心头荡漾。 软泥上的青荇， 油油的在水底招摇； 在康河的柔波里， 我甘心做一条水草！\n  那榆荫下的一潭， 不是清泉， 是天上虹； 揉碎在浮藻间， 沉淀着彩虹似的梦。 寻梦？撑一支长篙， 向青草更青处漫溯； 满载一船星辉， 在星辉斑斓里放歌。 但我不能放歌， 悄悄是别离的笙箫； 夏虫也为我沉默， 沉默是今晚的康桥！ 悄悄的我走了， 正如我悄悄的来； 我挥一挥衣袖， 不带走一片云彩。\n  包含引用的列表 语法说明： 如果要在列表项目内放进引用，那 \u0026gt; 就需要缩进：\n代码 1 2 3  * 阅读的方法: \u0026gt; 打开书本。 \u0026gt; 打开电灯。   样式   阅读的方法\n 打开书本\n打开电灯\n   包含代码区块的引用？ 语法说明 如果要放代码区块的话，该区块就需要缩进两次，也就是 8 个空格或是 2 个制表符：\n特殊情况 在特殊情况下，项目列表很可能会不小心产生，像是下面这样的写法：\n1 2  1986. What a great season. 显示What a great season.   换句话说，也就是在行首出现数字-句点-空白，要避免这样的状况，你可以在句点前面加上反斜杠：\n1  1986\\. What a great season.   引用 语法说明 引用需要在被引用的文本前加上\u0026gt;符号。\n代码 1 2 3 4 5 6  \u0026gt; 这是一个有两段文字的引用, \u0026gt; 无意义的占行文字1. \u0026gt; 无意义的占行文字2. \u0026gt; \u0026gt; 无意义的占行文字3. \u0026gt; 无意义的占行文字4.   样式  这是一个有两段文字的引用, 无意义的占行文字 1. 无意义的占行文字 2.\n无意义的占行文字 3. 无意义的占行文字 4.\n Markdown 也允许你偷懒只在整个段落的第一行最前面加上 \u0026gt; ：\n引用的多层嵌套 区块引用可以嵌套（例如：引用内的引用），只要根据层次加上不同数量的 \u0026gt; ：\n代码 1 2 3  \u0026gt;\u0026gt;\u0026gt; 请问 Markdwon 怎么用？ - 小白 \u0026gt;\u0026gt; 自己看教程！ - 愤青 \u0026gt; 教程在哪？ - 小白      请问 Markdwon 怎么用？ - 小白\n  自己看教程！ - 愤青\n 教程在哪？ - 小白\n      引用其它要素 引用的区块内也可以使用其他的 Markdown 语法，包括标题、列表、代码区块等：\n代码 1 2 3 4 5 6 7  \u0026gt; 1. 这是第一行列表项。 \u0026gt; 2. 这是第二行列表项。 \u0026gt; \u0026gt; 给出一些例子代码： \u0026gt; \u0026gt; return shell_exec(\u0026#34;echo $input | $markdown_script\u0026#34;);     这是第一行列表项。 这是第二行列表项。  给出一些例子代码：\nreturn shell_exec(\u0026quot;echo $input | $markdown_script\u0026quot;);   ==提示==\n快捷键：option+command+Q\n 空格\n 插入图像 图片的创建方式与超链接相似，而且和超链接一样也有两种写法，行内式和参考式写法。\n语法中图片 Alt 的意思是如果图片因为某些原因不能显示，就用定义的图片 Alt 文字来代替图片。 图片 Title 则和链接中的 Title 一样，表示鼠标悬停与图片上时出现的文字。 Alt 和 Title 都不是必须的，可以省略，但建议写上。\n提示：图片地址通过ipac上传至图床（网络地址）或者点击，网页复制到typora中ctrl+v即可，也可以复制图片shift+command+u上传至图床\n快捷键 cotrol+command+i\n行内式 语法说明 1  ![图片Alt](图片地址 “图片Title”)   样式 ![图片Alt](图片地址 “图片 Title”)\n参考式 语法说明 1 2 3  在文档要插入图片的地方写![图片Alt][标记] 在文档的最后写上[标记]:图片地址 “Title”   代码 1 2 3 4  美丽花儿： ![美丽花儿][flower] [flower]:http://ww2.sinaimg.cn/large/56d258bdjw1eugeubg8ujj21kw16odn6.jpg \u0026#34;美丽花儿\u0026#34;   美丽花儿： 目录 在段落中填写 [TOC] 以显示全文内容的目录结构。\n脚注 语法说明 1 2 3 4 5  语法说明： 在需要添加注脚的文字后加上脚注名字[^注脚名字],称为加注。 然后在文本的任意位置(一般在最后)添加脚注，脚注前必须有对应的脚注名字。 注意：经测试注脚与注脚之间必须空一行，不然会失效。成功后会发现，即使你没有把注脚写在文末，经Markdown转换后，也会自动归类到文章的最后。   代码 1 2 3 4  使用 Markdown[^1]可以效率的书写文档, 直接转换成 HTML[^2], 你可以使用 Leanote[^Le] 编辑器进行书写。 [^1]:Markdown是一种纯文本标记语言 [^2]:HyperText Markup Language 超文本标记语言 [^Le]:开源笔记平台，支持Markdown和笔记直接发为博文   样式 使用 Markdown1可以效率的书写文档, 直接转换成 HTML2, 你可以使用 Leanote3 编辑器进行书写。\nLaTeX 公式? $表示行内公式 代码 1  质能守恒方程可以用一个很简洁的方程式 $E=mc^2$ 来表达。   样式 质能守恒方程可以用一个很简洁的方程式 $E=mc^2$ 来表达。\n$$ 表示整行公式 代码 1 2 3 4  $$\\sum_{i=1}^n a_i=0$$ $$f(x_1,x_x,\\ldots,x_n) = x_1^2 + x_2^2 + \\cdots + x_n^2 $$ $$\\sum^{j-1}_{k=0}{\\widehat{\\gamma}_{kj} z_k}$$   样式 $$\\sum_{i=1}^n a_i=0$$ $$f(x_1,x_x,\\ldots,x_n) = x_1^2 + x_2^2 + \\cdots + x_n^2 $$ $$\\sum^{j-1}{k=0}{\\widehat{\\gamma}{kj} z_k}$$\n详情\n提示\n行内公式快捷键cotrol+m\n公式块快捷键option+command+B\n流程图 代码 1 2 3 4 5 6 7 8 9 10  flow st=\u0026gt;start: Start:\u0026gt;https://www.zybuluo.com io=\u0026gt;inputoutput: verification op=\u0026gt;operation: Your Operation cond=\u0026gt;condition: Yes or No? sub=\u0026gt;subroutine: Your Subroutine e=\u0026gt;end st-\u0026gt;io-\u0026gt;op-\u0026gt;cond cond(yes)-\u0026gt;e cond(no)-\u0026gt;sub-\u0026gt;io   详情\n表格 语法说明  不管是哪种方式，第一行为表头，第二行分隔表头和主体部分，第三行开始每一行为一个表格行。 列于列之间用管道符|隔开。原生方式的表格每一行的两边也要有管道符。 第二行还可以为不同的列指定对齐方向。默认为左对齐，在-右边加上:就右对齐。  代码 简单方式写表格：\n1 2 3 4 5  学号|姓名|分数 -|-|- 小明|男|75 小红|女|79 小陆|男|92   原生方式写表格：\n1 2 3 4 5  |学号|姓名|分数| |-|-|-| |小明|男|75| |小红|女|79| |小陆|男|92|   为表格第二列指定方向：\n1 2 3 4  产品|价格 -|-: Leanote 高级账号|60元/年 Leanote 超级账号|120元/年      学号 姓名 分数     小明 男 75   小红 女 79   小陆 男 92       学号 姓名 分数     小明 男 75   小红 女 79   小陆 男 92       产品 价格     Leanote 高级账号 60 元/年   Leanote 超级账号 120 元/年    ==提示==\n快捷键option+command+t\n分割线 你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线\n代码 1 2 3 4 5  * * * *** ***** - - - ---------------------------------------   样式      插入代码 对于程序员来说这个功能是必不可少的，插入程序代码的方式有两种，一种是利用缩进(Tab), 另一种是利用”`”符号（一般在 ESC 键下方）包裹代码。\n语法说明：\n插入行内代码，即插入一个单词或者一句代码的情况，使用code这样的形式插入。 插入多行代码，可以使用缩进或者“ code “,具体看示例。 注意： 缩进式插入前方必须有空行\n行内式 代码 1  C语言里的函数 `scanf()` 怎么使用？   C 语言里的函数 int 怎么使用？\n缩进式多行代码 缩进 4 个空格或是 1 个制表符\n一个代码区块会一直持续到没有缩进的那一行（或是文件结尾）。\n代码 1 2 3 4 5  #include \u0026lt;stdio.h\u0026gt; int main(void) { printf(\u0026#34;Hello world\\n\u0026#34;); }   用六个`包裹多行代码 代码 1 2 3 4 5 6 7  ``` #include \u0026lt;stdio.h\u0026gt;int main(void) { printf(\u0026#34;Hello world\\n\u0026#34;); } 、、、   提示\n快捷键option+command+c\nHTML 原始码 在代码区块里面， \u0026amp; 、 \u0026lt; 和 \u0026gt; 会自动转成 HTML 实体，这样的方式让你非常容易使用 Markdown 插入范例用的 HTML 原始码，只需要复制贴上，剩下的 Markdown 都会帮你处理，例如：\n代码 第一个例子：\n1 2 3  \u0026lt;div class=\u0026#34;footer\u0026#34;\u0026gt; © 2004 Foo Corporation \u0026lt;/div\u0026gt;   第二个例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13  \u0026lt;table\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th rowspan=\u0026#34;2\u0026#34;\u0026gt;值班人员\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;星期一\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;星期二\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;星期三\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;李强\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;张明\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;王平\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt;     Markdown 是一种纯文本标记语言\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n HyperText Markup Language 超文本标记语言\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n 开源笔记平台，支持 Markdown 和笔记直接发为博文\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   ","date":"2022-05-14T00:00:00Z","permalink":"https://example.com/2022/basic-%E8%AF%AD%E6%B3%95/","title":"Basic 语法"},{"content":" 文字排版+数学公式\n 希腊字母 $$ \\delta,\\lambda\\ \\Delta,\\Lambda\\ \\Alpha\\Beta\\ \\phi,\\varphi\\ \\epsilon,\\varepsilon\\ π $$\n上下标 $$ a^2,a_1\\ x^{y+z},p_{ij},p_ij\\ x_i,x_{\\text i}\\ \\text{A B},\\rm{A B}\\ \\text A B,\\rm A B\\ {\\rm A} B\\ \\text{e},\\text{i} $$\n分式与根式 $$ \\frac{1}{2},\\frac 1 2,\\ \\frac 1 {x+y}\\ \\frac {\\dfrac 1 x + 1}{y + 1} $$\n$$ \\sqrt 2,\\sqrt{x+y},\\sqrt[3]x $$\n普通运算符 $$ +-\\ \\times,\\cdot,\\div\\ \\pm,\\mp\\\n \u0026lt;,\\ge,\\le,\\gg,\\ll,\\ne,\\approx,\\equiv\\ \\cap,\\cup,\\in,\\notin,\\subseteq,\\subsetneqq,\\varnothing\\ \\forall,\\exists,\\nexists\\ \\because,\\therefore\\ \\mathbb R,\\R,\\Q,\\N,\\Z_+\\ \\mathcal F,\\mathscr F $$\n $$ \\cdots,\\vdots,\\ddots $$\n$$ \\infty,\\partial,∂,\\nabla,\\propto,\\degree $$\n$$ \\sin x,\\sec x,\\cosh x\\ \\log_2 x, \\ln x,\\lg x\\ \\lim\\limits_{x \\to 0} \\frac { x}{\\sin x}\\ \\max x $$\n$$ \\text{MSE}(x) $$\n大型运算符 $$ \\sum,\\prod\\ \\sum_i,\\sum_{i=0}^N\\ \\frac{\\sum\\limits_{i=1}^n x_i}{\\prod\\limits_{i=1}^n x_i} $$\n$$ \\int,\\iint,\\iiint,\\oint,\\oiint\\ \\int_{-\\infty}^0 f(x),\\text d x $$\n$$ a, a\\ a\\ a\\ a\\quad a\\ a\\qquad a $$\n标注符号 $$ \\vec x,\\overrightarrow {AB}\\ \\bar x,\\overline{AB} $$\n箭头 $$ \\leftarrow,\\Rightarrow,\\Leftrightarrow,\\longleftarrow $$\n括号与定界符 $$ ([]){ }\\ \\lceil,\\rceil,\\lfloor,\\rfloor,||\\ \\left(0,\\frac 1 a\\right]\\ \\left.\\frac {∂f}{∂x}\\right|_{x=0} $$\n多行公式 $$ \\begin{align}\na\u0026amp;=b+c+d\\ \u0026amp;=e+f\n\\end{align} $$\n大括号 $$ f(x)=\n\\begin{cases}\n\\sin x, \u0026amp; -π\\le x \\le π\\ 0,\u0026amp; \\text{其他}\n\\end{cases} $$\n矩阵 $$ \\begin{matrix}\na \u0026amp; b \u0026amp; \\cdots \u0026amp; c \\ \\vdots\u0026amp; \\vdots \u0026amp; \\ddots \u0026amp; \\vdots \\ e \u0026amp; f\u0026amp; \\cdots \u0026amp; g\n\\end{matrix} $$\n$$ \\begin{bmatrix}\na \u0026amp; b \u0026amp; \\cdots \u0026amp; c \\ \\vdots\u0026amp; \\vdots \u0026amp; \\ddots \u0026amp; \\vdots \\ e \u0026amp; f\u0026amp; \\cdots \u0026amp; g\n\\end{bmatrix}\n\\begin{pmatrix}\na \u0026amp; b \u0026amp; \\cdots \u0026amp; c \\ \\vdots\u0026amp; \\vdots \u0026amp; \\ddots \u0026amp; \\vdots \\ e \u0026amp; f\u0026amp; \\cdots \u0026amp; g\n\\end{pmatrix}\n\\begin{vmatrix}\na \u0026amp; b \u0026amp; \\cdots \u0026amp; c \\ \\vdots\u0026amp; \\vdots \u0026amp; \\ddots \u0026amp; \\vdots \\ e \u0026amp; f\u0026amp; \\cdots \u0026amp; g\n\\end{vmatrix} $$\n$$ \\bf A,\\bf B^{\\rm T} $$\n实战演练 $$ f(x) = \\frac 1 {\\sqrt{2\\pi} \\sigma} {\\rm e} ^ {-\\frac {(x-\\mu)^2}{2\\sigma ^ 2}}\\ f(x) = \\frac 1 {\\sqrt{2\\pi} \\sigma} \\exp \\left[ {-\\frac {(x-\\mu)^2}{2\\sigma ^ 2}}\\right] $$\n$$ \\lim\\limits_{N\\to \\infty} P \\left{ \\left| \\frac {I\\left( \\alpha_i \\right)}{N} - H(s) \\right| \u0026lt; \\varepsilon \\right} = 1 $$\n$$ x(n) = \\frac 1 {2\\pi} \\int _{-π} ^ π X\\left( {\\rm e} ^ {{\\rm j} \\omega } \\right) {\\rm e} ^ {{\\rm j} \\omega n} , {\\rm d}\\omega\\ $$\n$$ \\begin{align}\n\\vec B \\left( \\vec r \\right) \u0026amp;= \\frac {\\mu_0}{4\\pi}\\oint_C \\frac {I , {\\rm d} \\vec l \\times \\vec R}{R^3}\\\n\u0026amp;= \\frac {\\mu_0}{4\\pi} \\int_V \\frac{\\vec J_V \\times \\vec R}{R^3}, {\\rm d} V'\n\\end{align} $$\n","date":"2022-05-14T00:00:00Z","permalink":"https://example.com/2022/latex-%E5%85%AC%E5%BC%8F/","title":"LaTeX 公式"},{"content":"1  \u0026lt;img src=\u0026#34;https://tva1.sinaimg.cn/large/e6c9d24egy1h2bcvf3y8tj20u00u076i.jpg\u0026#34; style=\u0026#34;zoom:25%;\u0026#34; /\u0026gt;   图注 1 2 3 4 5  \u0026lt;center\u0026gt; \u0026lt;img src =\u0026#34;https://tva1.sinaimg.cn/large/e6c9d24egy1h2bdeapjzbj20u00u0wgb.jpg\u0026#34; width = 50% \u0026gt; \u0026lt;br\u0026gt; 头像👤 \u0026lt;/center\u0026gt;   提示\n1  \u0026lt;center\u0026gt;表示居中   表示左对齐\n1  \u0026lt;left\u0026gt;表示左对齐   图片并排\n1 2 3 4 5 6  \u0026lt;center\u0026gt; \u0026lt;img src =\u0026#34;https://tva1.sinaimg.cn/large/e6c9d24egy1h2bdeapjzbj20u00u0wgb.jpg\u0026#34; width = 25% \u0026gt; \u0026lt;img src =\u0026#34;https://tva1.sinaimg.cn/large/e6c9d24egy1h2bdeapjzbj20u00u0wgb.jpg\u0026#34; width = 25% \u0026gt; \u0026lt;br\u0026gt; 头像👤 \u0026lt;/center\u0026gt;   *提示：比例过大会撑开换行\n","date":"2022-05-14T00:00:00Z","permalink":"https://example.com/2022/picture-%E6%8E%92%E7%89%88/","title":"Picture 排版"}]